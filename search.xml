<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker进阶</title>
      <link href="/ArthurDream/2020/11/03/Docker%E8%BF%9B%E9%98%B6-1/"/>
      <url>/ArthurDream/2020/11/03/Docker%E8%BF%9B%E9%98%B6-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="1-Dockerfile介绍"><a href="#1-Dockerfile介绍" class="headerlink" title="1.Dockerfile介绍"></a>1.Dockerfile介绍</h2><p>dockerfile 是用来构建docker镜像的文件！是一个由命令参数构成的脚本！</p><p><strong>用dockerfile构建镜像的步骤：</strong></p><p>1、 编写一个dockerfile文件</p><p>2、 docker build 构建称为一个镜像</p><p>3、 docker run运行镜像</p><p>4、 docker push发布镜像（DockerHub 、阿里云仓库)</p><p>下面是官方镜像的一个dockerfile</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/官方的dockerfile.png" alt=""></p><p>可以看到官方镜像都是基础包，很多功能是没有的，所以我们通常会自己搭建自己的镜像。</p><h2 id="2-Dockerfile构建过程"><a href="#2-Dockerfile构建过程" class="headerlink" title="2.Dockerfile构建过程"></a>2.Dockerfile构建过程</h2><p><strong>基础知识：</strong></p><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、<strong>#</strong>表示注释</p><p>4、每一个指令都会创建提交一个新的镜像曾，并提交</p><p>下面是分层构建的思想，我们再一个基础镜像上一层层的构建我们需要的东西，最后我们他们打包发布，再去启动它的时候就是再加一个可写容器container层。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/dockerfile分层构建.png" alt=""></p><p>Dockerfile是面向开发的，我们以后要发布项目、做镜像，就需要编写dockerfile文件，这个文件也很简单。</p><p>步骤：开发、部署、上线运维</p><p><strong>DockerFile</strong>：构建文件，定义了一切的步骤，源代码</p><p><strong>DockerImages</strong>：通过DockerFile构建生成的镜像，最终发布和运行产品。（原来都是jar或war包，现在都把它们变成一个docker镜像）</p><p><strong>Docker容器</strong>：容器就是为镜像运行起来提供服务的。</p><h2 id="3-Dockerfile构建命令"><a href="#3-Dockerfile构建命令" class="headerlink" title="3.Dockerfile构建命令"></a>3.Dockerfile构建命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> DockerFile常用指令 </span></span><br><span class="line">FROM # 基础镜像，一切从这里开始构建 </span><br><span class="line">MAINTAINER # 镜像是谁写的， 姓名+邮箱 </span><br><span class="line">RUN # 镜像构建的时候需要运行的命令 </span><br><span class="line">ADD # 如添加tomcat镜像，会自动解压这个tomcat压缩包！添加内容 添加同目录 </span><br><span class="line">WORKDIR # 镜像的工作目录 </span><br><span class="line">VOLUME # 挂载的目录 </span><br><span class="line">EXPOSE # 保留端口配置 </span><br><span class="line">CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。 </span><br><span class="line">ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 </span><br><span class="line">ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指 令。</span><br><span class="line">COPY # 类似ADD，将我们文件拷贝到镜像中 </span><br><span class="line">ENV # 构建的时候设置环境变量</span><br></pre></td></tr></table></figure><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/趣说dockerfile命令.png" alt=""></p><h2 id="4-Dockerfile实战"><a href="#4-Dockerfile实战" class="headerlink" title="4.Dockerfile实战"></a>4.Dockerfile实战</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写Dockerfile文件</span></span><br><span class="line">vim mydockerfile-centos </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">基础镜像是centos，设置拥有者</span></span><br><span class="line">FROM centos </span><br><span class="line">MAINTAINER Arthur&lt;ArthurDream666@163.com&gt; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置环境变量目录，就是我进去这个镜像容器时，到达的目录是什么</span></span><br><span class="line">ENV MYPATH /usr/local </span><br><span class="line">WORKDIR $MYPATH </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">镜像构建时，执行一些yum安装指令</span></span><br><span class="line">RUN yum -y install vim </span><br><span class="line">RUN yum -y install net-tools </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">暴露80端口</span></span><br><span class="line">EXPOSE 80 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定这个容器启动的时候要运行的一些命令</span></span><br><span class="line">CMD echo $MYPATH </span><br><span class="line">CMD echo "-----end----" </span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>编写完成后通过docker build来构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2、通过这个文件构建镜像 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker build -f 文件路径 -t 镜像名:[tag] . </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下面最后冒号后面是标签，为0.1，注意0.1后的那个点一定不要丢</span></span><br><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br></pre></td></tr></table></figure><h3 id="CMD-和-ENTRYPOINT区别"><a href="#CMD-和-ENTRYPOINT区别" class="headerlink" title="CMD 和 ENTRYPOINT区别"></a>CMD 和 ENTRYPOINT区别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line">ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IaaS、PaaS与SaaS</title>
      <link href="/ArthurDream/2020/11/02/IaaS%E3%80%81PaaS%E4%B8%8ESaaS/"/>
      <url>/ArthurDream/2020/11/02/IaaS%E3%80%81PaaS%E4%B8%8ESaaS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IaaS、PaaS与SaaS"><a href="#IaaS、PaaS与SaaS" class="headerlink" title="IaaS、PaaS与SaaS"></a>IaaS、PaaS与SaaS</h1><h2 id="什么是云计算？"><a href="#什么是云计算？" class="headerlink" title="什么是云计算？"></a>什么是云计算？</h2><p>IaaS、PaaS、IaaS简单的说都属于云计算服务，也就是云计算+服务。</p><p>我们对于云计算的概念，<strong>维基百科有以下定义：Cloud computing is a new form of Internet-based computing that provides shared computer processing resources and data to computers and other devices on demand.</strong></p><p>云计算就是一种按照需求通过Internet获取计算资源的形态。这些计算资源被包装成为服务，提供给用户。而提供这些服务的主体，我们称之为云服务供应商（Cloud Service Provider）。</p><p>按照NIST (National Institute of Standards and Technology，美国国家标准和技术研究院)的定义，云服务最主要的有三类：IaaS、PaaS、SaaS。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>（Infrastructure as a service – 基础设施即服务）：用户可以在云服务提供商提供的基础设施上部署和运行任何软件，包括操作系统和应用软件。用户没有权限管理和访问底层的基础设施，如服务器、交换机、硬盘等，但是有权管理操作系统、存储内容，可以安装管理应用程序，甚至是有权管理网络组件。简单的说用户使用IaaS，有权管理操作系统之上的一切功能。我们常见的IaaS服务有虚拟机、虚拟网络、以及存储。</p><p>PaaS（Platform as a service – 平台即服务）：PaaS给用户提供的能力是使用由云服务提供商支持的编程语言、库、服务以及开发工具来创建、开发应用程序并部署在相关的基础设施上。这一层除了提供基础计算能力，还具备了业务的开发运行环境，提供包括应用代码、SDK、操作系统以及API在内的IT组件，供个人开发者和企业将相应功能模块嵌入软件或硬件，以提高开发效率。他们只能控制部署在基础设施中操作系统上的应用程序，配置应用程序所托管的环境的可配置参数。常见的PaaS服务有数据库服务、web应用以及容器服务。成熟的PaaS服务会简化开发人员，提供完备的PC端和移动端软件开发套件（SDK），拥有丰富的开发环境（Inteli、Eclipse、VS等），完全可托管的数据库服务，可配置式的应用程序构建，支持多语言的开发，面向应用市场。</p><p>SaaS（Software as a Service – 软件即服务）：SaaS给用户提供的能力是使用在云基础架构上运行的云服务提供商的应用程序。可以通过轻量的客户端接口（诸如web浏览器（例如，基于web的电子邮件））或程序接口从各种客户端设备访问应用程序。 用户无需管理或控制底层云基础架构，包括网络，服务器，操作系统，存储甚至单独的应用程序功能，可能的例外是有限的用户特定应用程序配置设置。类似的服务有：各类的网盘(Dropbox、百度网盘等)，JIRA，GitLab等服务。而这些应用的提供者不仅仅是云服务提供商，还有众多的第三方提供商（ISV: independent software provider）。</p><p>目前主流的IaaS、PaaS和SaaS产品如下图所示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/云计算.jpg" alt=""></p><p>除此之外，云计算目前主流的部署模式分为三类：</p><p>私有云（Private Cloud / On Premise）: 私有云是专为单个组织运营的云基础架构，管理的模式有内部管理，第三方管理，亦或是内部或外部托管。简单的讲，私有云就是通过自建或者租用场地的形式建立服务器机房或者数据中心。服务是面向私有网络或者VPN专有网络。企业拥有对服务器、数据硬盘的完全控制。因此安全性很高。</p><p>公有云（Public Cloud）：公有云服务面向公开网络暴露，服务可能也是免费的。由于网络对外公布，因此从安全层面上也是大不相同的。常见的公有云有AWS，Microsoft Azure，阿里云等。</p><p>混合云（Hybrid Cloud）：混合云是两个或多个云（私有云，社区云或公共云）的组合，（当企业既有私有云，同时又采用公有云计算服务时，这两种云之间形成一种内外数据相互流动的形态，便是混合云的模式。）它们保持不同的实体但绑定在一起，提供多个部署模型的好处。 混合云还意味着能够使用云资源连接搭配，托管和/或专用服务。比较常见的例子如数据公司，可能拥有很多数据，而这些数据因为合规性等原因只能放在私有环境，当需要大规模机器学习，对数据进行脱敏后使用公有云进行大规模学习。</p><p>另外，越来越多的数据沉淀、抽象形成了新的服务——<strong>DaaS</strong>（Data as a Service，<strong>数据即服务</strong>）。</p><p>数据聚合抽象，把数据转换成通用信息，从而为公众提供公共信息服务。例如，对于天气信息，可能A需要根据天气信息来判断出门穿着，B需要根据天气信息判断是否洗车，C需要根据天气信息判断是否准备防洪防涝设施等。不同用户均可利用DaaS满足自己的诉求。</p><p>此外，通过对各类数据信息进一步加工形成信息组合应用，会进一步盘活数据，提升数据价值。这就像搭积木一样，对基础数据信息块以不同的方式进行组装，可以达到千变万化的效果。DaaS服务已成为当下数字化转型的重要抓手。</p><p><strong>对企业而言，可根据需要使用上述某一种层次的云服务。</strong>大型企业一般需要综合上述四个层次的云服务，即层次化的云计算服务，一般也称为I-P-S&amp;D云计算，各层可独立提供云服务，下一层的架构为上一层云计算提供支撑。例如，某视频网站采用了上述的I-P-S&amp;D云计算架构。</p><p>其中，由阿里云大型服务器群、高速网络、存储系统等组成IaaS架构提供基础服务；将阿里云提供的RDS、MQ等服务构建在IaaS层上；这些RDS、MQ提供的服务组成PaaS，把视频的应用逻辑（如视频编解码、视频流接入等）部署上来，提供在线的视频点播、直播等服务。</p><p>这样一个大型的系统对互联网用户而言，就是一个大规模视频类SaaS应用。对日常用户访问日志、视频观看爱好等数据做进一步的聚合分析之后，便可形成千人千面、精准推送等DaaS服务。</p><p>目前，<strong>大型企业迁云时都倾向使用混合云模式</strong>，把面向互联网用户的应用系统部署在公有云上，把内部系统或者安全等级要求较高的系统部署在私有云上。</p><h2 id="云服务的发展现状"><a href="#云服务的发展现状" class="headerlink" title="云服务的发展现状"></a><strong>云服务的发展现状</strong></h2><p>SasS、IasS、PaaS这三种云服务模式目前处于不同的发展阶段。其中，<strong>SaaS和IaaS产业比较成熟，PaaS领域起步最晚</strong>，提供该服务的企业并不多。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/云服务发展现状.jpg" alt=""></p><p>从上图中可以看到，<strong>国内的云计算服务近年均以SaaS和IaaS为主，PaaS占比较小。</strong></p><p><strong>本文部分摘自知乎</strong>：<a href="https://www.zhihu.com/question/20387284/answer/743669668" target="_blank" rel="noopener">西门子中国</a></p><p><strong>本文部分摘自今日头条</strong>：<a href="toutiao.com/i6755388758754853379/?wxshare_count=2&amp;from=singlemessage&amp;timestamp=1572912356&amp;app=news_article&amp;req_id=201911050805560100140470381BC31887&amp;group_id=6755388758754853379&amp;pbid=6742724343454959107">IaaS、PaaS、SaaS、DaaS都是什么？现在怎么样了？终于有人讲明白了</a></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="/ArthurDream/2020/10/29/Docker/"/>
      <url>/ArthurDream/2020/10/29/Docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h2><p>在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件   对资源充分利用</p><p>虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Docker小鲸鱼.png" alt=""></p><p>Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><h2 id="为什么选择Docker"><a href="#为什么选择Docker" class="headerlink" title="为什么选择Docker?"></a>为什么选择Docker?</h2><p>（1）上手快。</p><p>用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。    </p><p> 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p><p>（2）职责的逻辑分类</p><p>使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><p>（3）快速高效的开发生命周期</p><p>Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><p>（4）鼓励使用面向服务的架构</p><p>Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><h2 id="Docker-的用途"><a href="#Docker-的用途" class="headerlink" title="Docker 的用途"></a>Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="Docker容器与虚拟机比较"><a href="#Docker容器与虚拟机比较" class="headerlink" title="Docker容器与虚拟机比较"></a>Docker容器与虚拟机比较</h2><p>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/docker与虚拟机的比较.png" alt=""></p><h2 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a>Docker 组件</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><p><strong>镜像（image)：</strong></p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像—-&gt;run—-&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p><p><strong>容器(container)：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p><p><strong>仓库(repository)：</strong></p><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的，可以自己配置阿里云加速。</p><h3 id="Docker的运行流程"><a href="#Docker的运行流程" class="headerlink" title="Docker的运行流程"></a>Docker的运行流程</h3><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/docker组成与运行流程.png" alt=""></p><p><strong>docker pull</strong>:首先docker pull向docker daemon发送了一条命令pull,告诉docker daemon要拉取某一个镜像,docker daemon会在本机检查镜像是否存在,如果存在且版本就是我们想要拉取的版本,它就不会做任何的操作.如果不存在下一步它会到docker的仓库中找我们要拉取的镜像名字,如果找到了就会有docker仓库传送到我们的本地,把我们要的镜像传送到我们的本地来。</p><p><strong>docker run</strong>:首先把命令发送到我们的docker daemon,docker daemon会先检查镜像在本机是否存在,如果不存在相当于执行了一个docker pull的过程,下载回来之后会以一定方式把镜像运行起来变成docker容器。</p><h3 id="Registry（注册中心）"><a href="#Registry（注册中心）" class="headerlink" title="Registry（注册中心）"></a>Registry（注册中心）</h3><p>Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hub.docker.com/</span><br></pre></td></tr></table></figure><h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><p>（1）yum 包更新到最新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>（3）设置yum源为阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>（4）安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>（5）安装后查看docker版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h2 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h2><p>登录阿里云，找到<strong>容器镜像服务</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/配置阿里云加速器.png" alt=""></p><p>将如下的4条指令依次在终端中运行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["这里是你自己的地址"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h2><p><strong>systemctl</strong>命令是系统服务管理器指令</p><p>启动docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>开机启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>查看docker概要信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看docker帮助文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><h3 id="镜像重命名"><a href="#镜像重命名" class="headerlink" title="镜像重命名"></a>镜像重命名</h3><p>docker     tag     镜像id     新名字：新tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pujh/centos         tomcat-centos       70ff7873d7cd        About an hour ago   612 MB</span><br><span class="line">docker.io/centos    latest              9f38484d220f        11 days ago         202 MB</span><br><span class="line">[root@localhost ~]# docker tag 70ff7873d7cd my_centos:tomcat-centos</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">my_centos           tomcat-centos       70ff7873d7cd        About an hour ago   612 MB</span><br><span class="line">pujh/centos         tomcat-centos       70ff7873d7cd        About an hour ago   612 MB</span><br><span class="line">docker.io/centos    latest              9f38484d220f        11 days ago         202 MB</span><br></pre></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反应一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>拉取镜像就是从中央仓库中下载镜像到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure><p>例如，我要下载centos7镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>按镜像ID删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure><p>查看最后一次运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure><p>查看停止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure><p>查看容器ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f '&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' container_name_or_id(容器的名称或者id)</span><br></pre></td></tr></table></figure><h3 id="容器重命名"><a href="#容器重命名" class="headerlink" title="容器重命名"></a>容器重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker rename my_container my_new_container</span></span><br></pre></td></tr></table></figure><h3 id="创建与启动容器"><a href="#创建与启动容器" class="headerlink" title="创建与启动容器"></a>创建与启动容器</h3><p>创建容器常用的参数说明：</p><p>创建容器命令：docker run</p><p> -i：表示运行容器</p><p> -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p> —name :为创建的容器命名。</p><p> -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p> -d:  后台运行容器，并返回容器ID。在run后面加上-d参数,则会创建一个守护式容器在后台运行,-（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p> -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p><p>（1）交互式方式创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态  </p><p>退出当前容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>（2）守护式方式创建容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure><p>登录守护式容器方式(即进入当前正在运行的容)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  /bin/bash</span><br></pre></td></tr></table></figure><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash</p><h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><p>停止容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><p>停止所有的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure><p>也可以将文件从容器内拷贝出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。（后面数据卷部分会有详细介绍）<br>创建容器 添加-v参数 后边为   宿主机目录:容器目录，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</span><br></pre></td></tr></table></figure><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数  —privileged=true  来解决挂载的目录没有权限的问题</p><h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><p>我们可以通过以下命令查看容器运行的各种数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p>也可以执行下面的命令直接输出IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' 容器名称（容器ID）</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>删除指定的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>重启指定的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart +容器ID</span><br></pre></td></tr></table></figure><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><p>如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理类似 </span></span><br><span class="line">docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure><p>实战测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个默认的</span></span><br><span class="line">tomcat docker run -d -p 8080:8080 tomcat </span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！ </span></span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、拷贝文件进去 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、将操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。 docker commit -m=<span class="string">"描述信息"</span> -a=<span class="string">"作者"</span> 容器id 目标镜像名:[TAG] </span></span><br><span class="line">docker commit -a="kuangshen" -m="add webapps app" 容器id tomcat02:1.0</span><br></pre></td></tr></table></figure><h2 id="Docker可视化工具"><a href="#Docker可视化工具" class="headerlink" title="Docker可视化工具"></a>Docker可视化工具</h2><p> <strong>portainer</strong>是Docker图形化界面管理工具！他能提供一个后台面板供我们进行可视化的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行如下命令即可打开可视化服务 </span></span><br><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line"><span class="meta">#</span><span class="bash">输入完上面一条后，下面一条配置语句也要输入执行</span></span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>安装完后可进行访问测试：<a href="http://ip:8088/（ip可为你自己的外网ip）" target="_blank" rel="noopener">http://ip:8088/（ip可为你自己的外网ip）</a></p><p>具体可以自己查查怎么用，我也没怎么研究过，哈哈~</p><h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h2><p>（1）拉取mysql镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=tensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure><p>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD  是root用户的登陆密码</p><p>（3）远程登录mysql</p><p>连接宿主机的IP  ,指定端口为3306 (意思为通过公网的3306端口可以访问docker容器内的3306端口)</p><h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><p>（1）拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><p>创建容器  -p表示地址映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 </span><br><span class="line">-v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure><h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><p>（1）拉取镜像    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>（2）创建Nginx容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><p>（1）拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><h2 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h2><p>我们可以通过以下命令将容器保存为镜像（提交一个自己的镜像）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure><h2 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h2><p>我们可以通过以下命令将镜像保存为tar 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><h2 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h2><p>首先我们先删除掉mynginx_img镜像  然后执行此命令进行恢复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="容器数据卷的概念"><a href="#容器数据卷的概念" class="headerlink" title="容器数据卷的概念"></a>容器数据卷的概念</h2><p>讲到容器数据卷首先我们先来回顾一下Docker的理念：</p><p>Docker将应用和环境打包成一个镜像！</p><p>想象以下两种情形：</p><p>（1）如果数据都在容器中，那么我们容器删除，数据就会丢失！<strong>需求</strong>：数据可以持久化</p><p>（2）数据存在MySQL里，容器删除了，删库跑路！<strong>需求</strong>：MySQL数据可以存储在本地！</p><p>其实，容器之间可以有一个数据共享的技术，能够将Docker容器中产生的数据，同步到本地。这就是卷技术，通过目录的挂载，进行双向绑定，将我们容器内的目录，挂载到Linux上面。</p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p><strong>直接使用命令挂载 -v</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-v, --volume                    list Bind mount a volume </span><br><span class="line"></span><br><span class="line">docker run -it -v 主机目录:容器内目录 -p 主机端口:容器内端口 </span><br><span class="line">➜ ~ docker run -it -v /home/ceshi:/home centos /bin/bash </span><br><span class="line"><span class="meta">#</span><span class="bash">通过 docker inspect 容器id 查看</span></span><br></pre></td></tr></table></figure><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/数据卷挂载.png" alt=""></p><p>接着测试是否真正同步：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/测试是否同步.png" alt=""></p><p>再来测试！</p><p>1、停止容器</p><p>2、宿主机修改文件</p><p>3、启动容器</p><p>4、容器内的数据依旧是同步的</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/数据卷挂载同步二次测试.png" alt=""></p><p><strong>好处：我们以后修改只需要在本地修改即可，容器内会自动同步。</strong></p><p><strong>挂载的同时创建容器可如下图</strong>：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/创建容器同时挂载.png" alt=""></p><h2 id="安装MySQL与数据持久化"><a href="#安装MySQL与数据持久化" class="headerlink" title="安装MySQL与数据持久化"></a>安装MySQL与数据持久化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取mysql镜像</span></span><br><span class="line">➜ ~ docker pull mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器,需要做数据挂载 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装启动mysql，需要配置密码的，这是要注意点！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考官网hub来配置mysql密码，比如：指定mysql的容器名称叫：mysql01,指定的root用户密码为：123456</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span></span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=你的密码 -d mysql:tag</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动我们的mysql -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 -- name 容器名字</span></span><br><span class="line">➜ ~ docker run -d -p 3306:3306 -v /mysql/conf:/etc/mysql/conf.d -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest mysql01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sqlyog-连接到服务器的3306--和容器内的3306映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></span><br></pre></td></tr></table></figure><p>假设我们将容器删除 ：</p><p><strong><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/mysql数据持久化.png" alt=""></strong></p><p>发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。</p><h2 id="匿名挂载和具名挂载"><a href="#匿名挂载和具名挂载" class="headerlink" title="匿名挂载和具名挂载"></a>匿名挂载和具名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载就是我们在 -v只写了容器内的路径，没有写容器外的路径！</span></span><br><span class="line">-v 容器内路径! </span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume的情况 </span></span><br><span class="line">➜ ~ docker volume ls</span><br><span class="line">DRIVER VOLUME NAME</span><br><span class="line">local 33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载 </span></span><br><span class="line">➜ ~ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx </span><br><span class="line">➜ ~ docker volume ls</span><br><span class="line">DRIVER VOLUME NAME </span><br><span class="line">local juming-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 卷名：容器内路径 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下这个卷</span></span><br><span class="line">docker volume inspect juming-nginx</span><br></pre></td></tr></table></figure><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/查看具名挂载.png" alt=""></p><p>所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxx/_data下</p><p>如果指定了目录，<strong>docker volume ls</strong> 是查看不到的。</p><p><strong>总结一下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三种挂载： 匿名挂载、具名挂载、指定路径挂载 </span></span><br><span class="line">-v 容器内路径 #匿名挂载 </span><br><span class="line">-v 卷名：容器内路径    #具名挂载 </span><br><span class="line">-v /宿主机路径：容器内路径 #指定路径挂载  docker volume ls 是查看不到的</span><br></pre></td></tr></table></figure><p><strong>拓展：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限 </span></span><br><span class="line">ro #readonly 只读 </span><br><span class="line">rw #readwrite 可读可写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一旦设置了容器的权限，容器对我们挂载出来的内容就有限定了</span></span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx </span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作的！</span></span><br></pre></td></tr></table></figure><h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>Dockerfile 就是用来构建docker镜像的构建文件的命令脚本，通过这个脚本可以生成镜像。镜像是一层一层的，脚本每个命令就相当于镜像的一层。</p><p>这里跟着视频粗略的尝试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议dockerfile1 </span></span><br><span class="line">vim dockerfile1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进来vim编辑器后，写脚本指令，文件中的内容格式为：指令(大写) 参数 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以centos为基础</span></span><br><span class="line">FROM centos </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过VOLUME来挂载</span></span><br><span class="line">VOLUME ["volume01","volume02"] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">为了确定挂在执行了，<span class="built_in">echo</span>一下，下面/bin/bash是确保进去是一个交互命令行</span></span><br><span class="line">CMD echo "----end----" </span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>可以看到 build时候，依次执行了脚本里的每一条指令。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/初识dockerfile运行.png" alt=""></p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h2><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table></div><h2 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h2><p>步骤：</p><p>（1）创建目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8</span><br></pre></td></tr></table></figure><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>（3）创建文件Dockerfile  <code>vi Dockerfile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">依赖镜像名称和ID</span></span><br><span class="line">FROM centos:7</span><br><span class="line"><span class="meta">#</span><span class="bash">指定镜像创建者信息</span></span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line"><span class="meta">#</span><span class="bash">切换工作目录</span></span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir  /usr/local/java</span><br><span class="line"><span class="meta">#</span><span class="bash">ADD 是相对路径jar,把java添加到容器中</span></span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置java环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>（4）执行命令构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t='jdk1.8' .</span><br></pre></td></tr></table></figure><p>注意后边的空格和点，不要省略</p><p>（5）查看镜像是否建立完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h1 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h1><h2 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h2><p>（1）拉取私有仓库镜像（此步省略）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p>（2）启动私有仓库容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}`</a> 表示私有仓库搭建成功并且内容为空</p><p>（4）修改daemon.json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容，保存退出。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"insecure-registries"</span>:[<span class="string">"192.168.184.141:5000"</span>]&#125;</span><br></pre></td></tr></table></figure><p>此步用于让 docker信任私有仓库地址</p><p>（5）重启docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag jdk1.8 192.168.184.141:5000/jdk1.8</span><br></pre></td></tr></table></figure><p>（2）再次启动私服容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>（3）上传标记的镜像 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.184.141:5000/jdk1.8</span><br></pre></td></tr></table></figure><p>写不动了今天先写到这里，有错误请指出</p><p>本文内容参考<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=20" target="_blank" rel="noopener">狂神B站教学视频及笔记</a>，内容挺好的，感兴趣的可以去看看他的教学视频</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（一）</title>
      <link href="/ArthurDream/2020/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/ArthurDream/2020/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p>网易：<a href="https://study.163.com/course/courseMain.htm?courseId=1210076550&amp;_trace_c_p_k2_=0a2e4dc11a114923ae0162cda9d5b46a" target="_blank" rel="noopener">吴恩达《机器学习》</a></p><p>B站：<a href="https://www.bilibili.com/video/BV164411b7dx?from=search&amp;seid=13232445094666472951" target="_blank" rel="noopener">[中英字幕]吴恩达机器学习系列课程</a></p><p>其他资料：<a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">Coursera-ML-AndrewNg-Notes</a></p><h2 id="章节-1-初识机器学习"><a href="#章节-1-初识机器学习" class="headerlink" title="章节 1 初识机器学习"></a>章节 1 初识机器学习</h2><h3 id="课时1-欢迎参加《机器学习》课程"><a href="#课时1-欢迎参加《机器学习》课程" class="headerlink" title="课时1 欢迎参加《机器学习》课程"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280908399&amp;courseId=1210076550" target="_blank" rel="noopener">课时1 欢迎参加《机器学习》课程</a></h3><p>第一个视频主要是讲什么是机器学习，介绍了一下机器学习能干什么（可以跳过）</p><h3 id="课时2-什么是机器学习"><a href="#课时2-什么是机器学习" class="headerlink" title="课时2 什么是机器学习"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280907405&amp;courseId=1210076550" target="_blank" rel="noopener">课时2 什么是机器学习</a></h3><p><strong>机器学习是什么？</strong></p><p>来自卡内基梅隆大学Tom Mitchel定义的机器学习为：一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当有了经验E后，经过P评判，程序在处理T时的性能有所提升。</p><p>简单来说：<strong>机器学习是用机器学习算法来建立模型，当有新的数据过来时，可以通过模型来进行预测。</strong></p><p>为方便理解，把机器学习的过程与人类对历史经验归纳的过程做个对比如下：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/什么是机器学习.png" alt="什么是机器学习"></p><h3 id="课时3-监督学习"><a href="#课时3-监督学习" class="headerlink" title="课时3 监督学习"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280910348&amp;courseId=1210076550" target="_blank" rel="noopener">课时3 监督学习</a></h3><p><strong>监督学习：</strong> 基本思想是，我们数据集中的每个样本都有相应的”正确答案“。再根据这些样本做出预测，就像房子问题和肿瘤问题</p><p><strong>（1）回归问题：</strong>通过回归来推出一个连续的输出</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/监督学习与回归问题.png" alt="监督学习与回归问题"></p><p><strong>（2）分类问题</strong>：分类指的是我们尝试推测出离散的输出值：0或1，良性或恶性，而事实上在分类问题中，输出可能不止两个值。比如说可能有三种乳腺癌，所以你希望预测离散输出0、1、2。0代表良性，1表示1类乳腺癌，2表示第2类乳腺癌，3表示第三类，这种也是分类问题。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/分类问题.png" alt="分类问题"></p><p><strong>小测验</strong>：假设你经营着一家公司，你想开发学习算法来处理这两个问题</p><p>a.你有一大批同样的货物，想象一下，你有上千件一模一样的货物等待出售，这时你</p><p>想预测接下来的三个月能卖多少件？这是个回归问题</p><p>b.你有许多客户，这时你想写一个软件来检验每一个用户的账户。对于每一个账户，</p><p>你要判断它们是否曾经被盗过？这是个分类问题</p><h3 id="课时4-无监督学习"><a href="#课时4-无监督学习" class="headerlink" title="课时4 无监督学习"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280912351&amp;courseId=1210076550" target="_blank" rel="noopener">课时4 无监督学习</a></h3><p><strong>无监督学习</strong>：它是学习策略，交给算法大量的数据，并让算法为我们从数据中找出某种结构。无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。针对数据集，无监督学习就能判断出数据有两个不同的聚集簇，所以叫做<strong>聚类算法</strong>。”这是一个，那是另一个，二者不同“。</p><p>这里把监督学习与无监督学习做一个直观的对比。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/监督学习与无监督学习.png" alt="监督学习与无监督学习"></p><p>可以看到<strong>监督学习</strong>的每个数据集中每条数据都已经表明了是阴性或阳性，即是良性或恶性肿瘤。所以，对于监督学习里的每条数据，我们已经清楚地知道，训练集对应的正确答案，是良性或恶性了。</p><p>在<strong>无监督学习</strong>中，我们已知的数据。看上去有点不一样，不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么。别的都不知道，就是一个数据集。无监督学习算法可能会把这些数据分成两个不同的簇，所以叫做聚类算法。</p><p><strong>举个例子</strong>：</p><p>垃圾邮件问题，如果你有标记好的数据，区别是垃圾还是非垃圾邮件，这是监督学习问题。</p><p>新闻事件分类：谷歌新闻将许多新闻分组，组成有关联的新闻，它做的就是搜索非常多的新闻事件，自动把他们聚类在一起。这是无监督学习问题。</p><h3 id="课时5-一些问题"><a href="#课时5-一些问题" class="headerlink" title="课时5 一些问题"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/text?lessonId=1280914356&amp;courseId=1210076550" target="_blank" rel="noopener">课时5 一些问题</a></h3><h2 id="章节-2-单变量线性回归"><a href="#章节-2-单变量线性回归" class="headerlink" title="章节 2 单变量线性回归"></a>章节 2 单变量线性回归</h2><p><strong>在进行章节2之前，先在此处说明一下描述这个回归问题的标记：</strong></p><p>𝑚 代表训练集中实例的数量</p><p>𝑥 代表特征/输入变量</p><p>𝑦 代表目标变量/输出变量</p><p>(𝑥, 𝑦) 代表训练集中的实例 </p><p>(𝑥(𝑖), 𝑦(𝑖)) 代表第𝑖 个观察实例</p><p>ℎ 代表学习算法的解决方案或函数也称为假设（hypothesis）</p><h3 id="课时6-模型描述"><a href="#课时6-模型描述" class="headerlink" title="课时6 模型描述"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280913357&amp;courseId=1210076550" target="_blank" rel="noopener">课时6 模型描述</a></h3><p><strong>公式：</strong>$h(x)=\theta_{0}+\theta_{1}x$， 这里的$\theta_{0}$和$\theta_{1}$代表参数。</p><p>因为只含有一个特征/输入变量，因此这样的问题叫作<strong>单变量线性回归问题</strong>。</p><h3 id="课时7-代价函数"><a href="#课时7-代价函数" class="headerlink" title="课时7 代价函数"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280912352&amp;courseId=1210076550" target="_blank" rel="noopener">课时7 代价函数</a></h3><p><strong>公式：</strong>$J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^{2}$</p><p><strong>建模误差：</strong>我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是<strong>建模误差</strong>（<strong>modeling error</strong>）。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/建模误差.png" alt="建模误差"></p><p>我们的目标便是<strong>选择出</strong>可以使得建模误差的平方和能够最小的<strong>模型参数</strong>，即使得代价函数$J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^{2}$最小。</p><p>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是<strong>回归问题，都是一个合理的选择</strong>。</p><h3 id="课时8-代价函数的直观理解（一）"><a href="#课时8-代价函数的直观理解（一）" class="headerlink" title="课时8 代价函数的直观理解（一）"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909359&amp;courseId=1210076550" target="_blank" rel="noopener">课时8 代价函数的直观理解（一）</a></h3><p>这里假设$\theta_0$=0，然后<img src= "/ArthurDream/img/loading.gif" data-src="https://math.jianshu.com/math?formula=%5Ctheta_1" alt="\theta_1">取不同的值画出函数</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/代价函数的直观理解1.png" alt="代价函数直观理解1"></p><h3 id="课时9-代价函数的直观理解（二）"><a href="#课时9-代价函数的直观理解（二）" class="headerlink" title="课时9 代价函数的直观理解（二）"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909359&amp;courseId=1210076550" target="_blank" rel="noopener">课时9 代价函数的直观理解（二）</a></h3><p>代价函数的样子，等高线图，则可以看出在三维空间中存在一个使得𝐽(𝜃0, 𝜃1)最小的点</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/代价函数三维.png" alt="代价函数三维"></p><h3 id="课时10-梯度下降"><a href="#课时10-梯度下降" class="headerlink" title="课时10 梯度下降"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280907406&amp;courseId=1210076550" target="_blank" rel="noopener">课时10 梯度下降</a></h3><p><strong>梯度下降算法</strong>是一个用来求代价函数最小值的算法，我们将使用梯度下降算法来求出代价函数$J(\theta_0,\theta_1)$的最小值。<strong>选择不同的初始参数组合，可能会找到不同的局部最小值。</strong></p><p>（背后的思想是：开始时我们随机选择一个参数的组合(𝜃0, 𝜃1, . . . . . . , 𝜃𝑛)，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。）</p><p><strong>公式：</strong></p><p><strong>$Gradient\ descent\ algorithm$:</strong></p><p>$repeat$  $until$  $convergence$ {</p><p>​        $\theta_{j} := \theta_{j} - \alpha \frac{\partial }{\partial \theta_{j}}J(\theta_{0},\theta_{1})$    ( for j=0 and j=1 )</p><p>}</p><p>$Correct: Simultaneous\ update$</p><p> $temp0:=\theta_0- \alpha \frac{\partial }{\partial \theta_{0}}J(\theta_{0},\theta_{1})$</p><p>$temp1:=\theta_{1} - \alpha \frac{\partial }{\partial \theta_{1}}J(\theta_{0},\theta_{1})$</p><p>$\theta_0\ :=temp0$</p><p>$\theta_1\ :=temp1$</p><p>公式符号解析：</p><p>$:=$ ，赋值</p><p>$\alpha$  :learning rate，学习率。</p><p>$\frac{\partial }{\partial \theta_{j}}J(\theta_{0},\theta_{1})$,这是个微分项，以后会有详细解释。</p><p><strong>Correct: Simultaneous update</strong>的意思是同时把$\theta_{0},\theta_{1}$代入公式后计算出的值再赋值给$\theta_{0},\theta_{1}$,<strong>也就是用一对参数同时经过公式计算后的结果再更新参数，即同步更新参数</strong>。<u><strong>梯度下降要同时更新</strong></u><strong>!</strong></p><h3 id="课时11-梯度下降知识点总结（直观感受）"><a href="#课时11-梯度下降知识点总结（直观感受）" class="headerlink" title="课时11 梯度下降知识点总结（直观感受）"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280910349&amp;courseId=1210076550" target="_blank" rel="noopener">课时11 梯度下降知识点总结（直观感受）</a></h3><p><strong>$Gradient\ descent\ algorithm$:</strong></p><p>$\theta_{j} := \theta_{j} - \alpha \frac{\partial }{\partial \theta_{j}}J(\theta_{0},\theta_{1})$  </p><p>$Description$：对𝜃赋值，使得𝐽(𝜃)按梯度下降最快方向进行，一直迭代下去，最终得到局部最小值。其中𝑎是学习率（<strong>learning rate</strong>），它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/梯度下降算法的直观感受.png" alt="梯度下降算法的直观感受"></p><p>求导的目的，基本上可以说取这个红点的切线，就是这样一条红色的直线，刚好与函数相切于这一点，这个导数是切率，此处这条线有一个正斜率，也就是说它有正导数，因此，我得到的新的𝜃1，𝜃1更新后等于𝜃1减去一个正数乘以𝑎。</p><p><strong>来看一个例子：</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/梯度下降算法例子.png" alt="梯度下降算法例子"></p><p>意思为当我们逐渐接近局部最小值，梯度下降算法的步子将自动的越迈越小，因为局部最低点的导数是等于0，我们接近最低点时，导数值会愈来愈恶小，梯度下降会自动采取较小的幅度，所以不需要另外减少$\alpha$。</p><p>可参考简书<strong>云上听风</strong>理解为（底部附有原文链接）：</p><p>我们的目的是让代价函数$J(\theta)$最小，而代价函数的大小是由多个参数$\theta$决定的，所以我们是要求出合适的)$\theta$参数。 一开始先随机取$\theta$，然后用梯度下降不断更新$\theta$，学习率就是更新的步伐，每次移动一点，当找到局部最优点时导数为0，此时$\theta$停止更新(减零等于没有更新)。所以梯度下降可以让我们找到局部最优点(局部最低点)。</p><h3 id="课时13-课程总结（PPT可跳过）"><a href="#课时13-课程总结（PPT可跳过）" class="headerlink" title="课时13 课程总结（PPT可跳过）"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/text?lessonId=1280915338&amp;courseId=1210076550" target="_blank" rel="noopener">课时13 课程总结（PPT可跳过）</a></h3><h2 id="章节3-线性代数回顾"><a href="#章节3-线性代数回顾" class="headerlink" title="章节3 线性代数回顾"></a><strong>章节3 线性代数回顾</strong></h2><h3 id="课时14至19"><a href="#课时14至19" class="headerlink" title="课时14至19"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280913358&amp;courseId=1210076550" target="_blank" rel="noopener">课时14至19</a></h3><p>均是非常基础的线性代数知识，此处略过</p><h2 id="章节4-软件安装配置"><a href="#章节4-软件安装配置" class="headerlink" title="章节4 软件安装配置"></a><strong>章节4 软件安装配置</strong></h2><h3 id="课时20至26"><a href="#课时20至26" class="headerlink" title="课时20至26"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/text?lessonId=1280908414&amp;courseId=1210076550" target="_blank" rel="noopener">课时20至26</a></h3><p>都是PPT，没啥好说的，直接略过</p><h2 id="章节5-多变量线性回归"><a href="#章节5-多变量线性回归" class="headerlink" title="章节5 多变量线性回归"></a><strong>章节5 多变量线性回归</strong></h2><h3 id="课时27多维特征"><a href="#课时27多维特征" class="headerlink" title="课时27多维特征"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280912355&amp;courseId=1210076550" target="_blank" rel="noopener">课时27多维特征</a></h3><p>现在我们对房价模型增加更多的特征，</p><p>例如房间数楼层等，构成一个含有多个变量的模型，模型中的特征为(𝑥1, 𝑥1, . . . , 𝑥𝑛)。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/多维特征.png" alt="多维特征"></p><p><strong>引入新的注释：</strong></p><p>$n$代表特征的数量。</p><p>𝑥(𝑖)代表第 𝑖 个训练实例，是特征矩阵中的第𝑖行，是一个<strong>向量</strong>（<strong>vector</strong>）。</p><p>上面的$x_0$值固定为1，是我们为了下面的矩阵运算而添加上去的。</p><p><strong>公式：</strong>$h_{\theta}(x)=\theta^TX=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$</p><p>$x_{j}^{(i)}$代表特征矩阵中第$i$行的第$j$个特征，也就是第<img src= "/ArthurDream/img/loading.gif" data-src="https://math.jianshu.com/math?formula=i" alt="i">个训练实例的第$j$个特征。 </p><p>$\theta^TX$中的$\theta$是列向量$\begin{bmatrix} \theta_0\\ \theta_1\\ …\\\theta_n\end{bmatrix}$,$X$为$\begin{bmatrix} x_0\\ x_1\\ …\\x_n\end{bmatrix}$</p><p>$\theta$转置后为：$\begin{bmatrix}\theta_0 &amp;\theta_1 &amp;… &amp;\theta_n \end{bmatrix}$，然后与列向量$X$相乘，自然就是$\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$。</p><h3 id="课时28-多变量梯度下降"><a href="#课时28-多变量梯度下降" class="headerlink" title="课时28-多变量梯度下降"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280913359&amp;courseId=1210076550" target="_blank" rel="noopener">课时28-多变量梯度下降</a></h3><p>构建一个代价函数，则这个代价函数是所有建模误差的平方和，即：</p><p>$J(\theta_0,\theta_1,…,\theta_n,)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^{2}$,</p><p>其中，$h_{\theta}(x)=\theta^TX=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$</p><p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。多变量线性回归的批量梯度下降算法为：</p><p>（懒得打了，直接截图吧）</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/多变量梯度下降算法 .png" alt="多变量梯度下降算法"></p><p>我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛</p><p>​        代码示例：</p><p>​        计算代价函数$J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^{2}$, 其中：$h_{\theta}(x)=\theta^TX=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$ </p><p><strong>Python</strong> 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    inner = np.power(((X * theta.T) - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sum(inner) / (<span class="number">2</span> * len(X))</span><br></pre></td></tr></table></figure><h3 id="课时29-梯度下降法实践1-特征缩放"><a href="#课时29-梯度下降法实践1-特征缩放" class="headerlink" title="课时29 梯度下降法实践1-特征缩放"></a><strong><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909361&amp;courseId=1210076550" target="_blank" rel="noopener">课时29 梯度下降法实践1-特征缩放</a></strong></h3><p><strong>特征缩放</strong>可以使梯度下降<strong>运行的更快</strong>。</p><p>最简单的方法是令：$x_n=\frac{x_n-\mu_n}{s_n}$,其中$\mu_n$是平均值，$s_n$是标准差（标准差是方差的算术平方根，标准差能反映一个数据集的离散程度）</p><h3 id="课时30-梯度下降法实践2-学习率"><a href="#课时30-梯度下降法实践2-学习率" class="headerlink" title="课时30 梯度下降法实践2-学习率"></a><strong><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909361&amp;courseId=1210076550" target="_blank" rel="noopener">课时30 梯度下降法实践2-学习率</a></strong></h3><p>学习率太小可能运行的太慢，学习率太大时可能不会在每次迭代时都下降，甚至可能不收敛。</p><p>通常，学习率<img src= "/ArthurDream/img/loading.gif" data-src="https://math.jianshu.com/math?formula=%5Calpha" alt="\alpha">的取值可以为：</p><p>𝛼 = 0.01<em>，</em>0.03<em>，</em>0.1<em>，</em>0.3<em>，</em>1<em>，</em>3<em>，</em>10</p><h3 id="课时31-特征和多项式回归"><a href="#课时31-特征和多项式回归" class="headerlink" title="课时31 特征和多项式回归"></a><strong><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909361&amp;courseId=1210076550" target="_blank" rel="noopener">课时31 特征和多项式回归</a></strong></h3><p>线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据。</p><p>比如一个:二次方模型：$h_\theta=\theta_0+\theta_1x_1+\theta_2 x_2^2$  ，或一个三次方模型：$h_\theta=\theta_0+\theta_1x_1+\theta_2 x_2^2+\theta_3 x_3^3$</p><p>通常我们需要先观察数据然后再决定准备尝试怎样的模型。 我们可以令：$x_2= x_2^2$，$x_3= x_3^3$，从而将模型转化为线性回归模型</p><h3 id="课时32-正规方程"><a href="#课时32-正规方程" class="headerlink" title="课时32 正规方程"></a><strong><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280909361&amp;courseId=1210076550" target="_blank" rel="noopener">课时32 正规方程</a></strong></h3><p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数：$ \frac{\partial }{\partial \theta_{j}}J(\theta_j)=0$。 </p><p>假设我们的训练集特征矩阵为 𝑋（包含了 $x_0$= 1）并且我们的训练集结果为向量 𝑦，则利用正规方程解出向量$\theta=(X^{T}X)^{-1}X^{T}y$</p><p>上标 <strong>T</strong> 代表矩阵转置，上标-1 代表矩阵的逆。设矩阵𝐴 = $X^{T}X$，则：$(X^{T}X)^{-1}$ =$A^{-1}$</p><p>以下表数据为例：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/正规方程.png" alt="正规方程"></p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/正规方程求解参数.png" alt="正规方程方法求解参数"></p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/梯度下降和正规方程对比.png" alt="梯度下降和正规方程对比"></p><p>正规方程的 <strong>python</strong> 实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalEqn</span><span class="params">(X, y)</span>:</span></span><br><span class="line"> theta = np.linalg.inv(X.T@X)@X.T@y <span class="comment">#X.T@X 等价于 X.T.dot(X)</span></span><br><span class="line"> <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><h3 id="课时33-——35不重要，略过"><a href="#课时33-——35不重要，略过" class="headerlink" title="课时33 ——35不重要，略过"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280911413&amp;courseId=1210076550" target="_blank" rel="noopener">课时33 ——35不重要，略过</a></h3><h2 id="章节6-Octave-Matlab教程"><a href="#章节6-Octave-Matlab教程" class="headerlink" title="章节6 Octave/Matlab教程"></a>章节6 Octave/Matlab教程</h2><p>没啥好说的，略过</p><h2 id="章节7-Logistic回归"><a href="#章节7-Logistic回归" class="headerlink" title="章节7 Logistic回归"></a>章节7 Logistic回归</h2><p><strong>引言：</strong></p><p>逻辑回归为什么叫逻辑回归？是因为使用了sigmoid函数，sigmoid函数本身也是Logistic function的一种形式，故此得名。逻辑回归是一种广义的线性回归分析模型，Sigmoid函数是逻辑回归的核心，通过Sigmoid函数将原本的线性回归问题转化成了一个分类问题。 Logistic回归是用来解决二类分类问题的，如果要解决的问题是多分类问题呢？那就要用到softmax回归了，它是Logistic回归在多分类问题上的推广。此处神经网络模型开始乱入，softmax回归一般用于神经网络的输出层，此时输出层叫做softmax层。(摘自<a href="https://www.jianshu.com/p/8cfb036136f5" target="_blank" rel="noopener">云上听风</a>)</p><h3 id="课时44——分类"><a href="#课时44——分类" class="headerlink" title="课时44——分类"></a><a href="https://study.163.com/course/courseLearn.htm?courseId=1210076550#/learn/video?lessonId=1280911413&amp;courseId=1210076550" target="_blank" rel="noopener">课时44——分类</a></h3><p>今天先写到这里</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis心得（转载）</title>
      <link href="/ArthurDream/2020/10/22/Redis%E5%BF%83%E5%BE%97%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/ArthurDream/2020/10/22/Redis%E5%BF%83%E5%BE%97%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis心得体会（转载）"><a href="#Redis心得体会（转载）" class="headerlink" title="Redis心得体会（转载）"></a>Redis心得体会（转载）</h1><h2 id="Redis简介："><a href="#Redis简介：" class="headerlink" title="Redis简介："></a>Redis简介：</h2><p>​         在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p><h2 id="NoSQL-技术："><a href="#NoSQL-技术：" class="headerlink" title="NoSQL 技术："></a>NoSQL 技术：</h2><p>解决了一系列问题，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。，因此出现了<strong>Redis</strong>和<strong>MongoDB，\</strong>Redis*<em>和*<em>MongoDB*<strong>*是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以</strong>支持每秒十几万此的读/写操作<strong>，其性能远超数据库，并且还</strong>支持集群、分布式、主从同步等<strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还</strong>支持一定的事务能力</em></em>，这保证了高并发的场景下数据的安全和一致性。</p><p><strong>Redis 在 Java Web 主要有两个应用场景：</strong></p><ul><li>存储 <strong>缓存</strong> 用的数据；</li><li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等</p><p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p><ul><li><strong>业务数据常用吗？命中率如何？</strong>如果命中率很低，就没有必要写入缓存；</li><li><strong>该业务数据是读操作多，还是写操作多？</strong>如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li><li><strong>业务数据大小如何？</strong>如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li></ul><p>使用 Redis 作为缓存的读取逻辑如下图所示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis1.png" alt="img"></p><p>从上图我们可以知道以下两点：</p><ol><li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li><li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。</li></ol><p>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</p><p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis2.png" alt="img"></p><p>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p><blockquote><p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p></blockquote><h2 id="高速读-写的场合"><a href="#高速读-写的场合" class="headerlink" title="高速读/写的场合"></a>高速读/写的场合</h2><p>在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有<strong>成千上万的请求</strong>到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，<strong>轻则造成用户体验极差用户量流失</strong>，<strong>重则数据库瘫痪，服务宕机</strong>，而这样的场合都是不允许的！</p><p>所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看<strong>一次请求操作的流程图</strong>：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis3.png" alt="img"></p><p>我们来进一步阐述这个过程：</p><ol><li>当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足<strong>高速响应的需求</strong>；</li><li>但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去<strong>判断该高速读/写的业务是否结束</strong>，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式<strong>一次性写入数据库</strong>，从而完成持久化的工作。</li></ol><p>加压后如图：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1715978/201907/1715978-20190715153757526-673189666.png" alt="img"></p><p>安装redis服务命令：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis5.png" alt="img"></p><p>需要注意的是：所有命令需要在window解压的redis根目录执行，免安装的情况下,window 切换目录需要首先切到盘符D：然后cd到盘符的指定路径</p><p>相关配置文件和官方文档都在下载的目录中，比如下面的conf文件可以修改服务的端口号，默认的是6397</p><p><strong>原文链接<a href="https://www.cnblogs.com/zoli/p/11189288.html" target="_blank" rel="noopener">https://www.cnblogs.com/zoli/p/11189288.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用Web组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程和多进程</title>
      <link href="/ArthurDream/2020/09/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/ArthurDream/2020/09/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><p>面试的时候，经常被问到 进程和线程的区别。</p><p>简单的说：<strong>进程就是运行着的程序</strong>。</p><p>我们写的python程序（或者其他应用程序比如画笔、qq等），运行起来，就称之为一个<strong>进程</strong></p><p>在windows下面打开任务管理器，里面显示了当前系统上运行着的进程。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/gh/36257654_36931680-3344f066-1ef6-11e8-9c71-bad64c5624c7.png" alt="白月黑羽Python3教程"></p><p>可以看到，我们系统中有很多的进程运行着，比如qq、搜狗输入法等。</p><p>这些程序还没有运行的时候，它们的程序代码文件存储在磁盘中，就是那些扩展名为 <code>.exe</code> 文件。</p><p>双击它们，这些 <code>.exe</code> 文件就被os加载到内存中，运行起来，成为进程</p><p>而系统中每个进程里面至少包含一个 <strong>线程</strong> 。</p><p>线程是操作系统创建的，每个线程对应一个代码执行的数据结构，保存了代码执行过程中的重要的状态信息。</p><p>没有线程，操作系统没法管理和维护 代码运行的状态信息。</p><p>所以没有创建线程之前，操作系统是不会执行我们的代码的。</p><p>我们前面写的Python程序，里面虽然没有创建线程的代码，但实际上，当Python解释器程序运行起来（成为一个进程），OS就自动的创建一个线程，通常称为<strong>主线程</strong>，在这个主线程里面执行代码指令。</p><p>当解释器执行我们python程序代码的时候。 我们的代码就在这个主线程中解释执行。</p><p>比如：下面这个程序，运行起来后，只有一个线程，就是主线程，在主线程里面，执行代码，顺序下来，一直执行到结束， 主线程就退出了。 同时进程也结束了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fee = input(<span class="string">'请输入午餐费用：'</span>)</span><br><span class="line">members = input(<span class="string">'请输入聚餐人姓名，以英文逗号,分隔：'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将人员放入一个列表</span></span><br><span class="line">memberlist = members.split(<span class="string">','</span>) </span><br><span class="line"><span class="comment"># 得到人数</span></span><br><span class="line">headcount = len(memberlist) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算人均费用</span></span><br><span class="line">avgfee = int (fee) / headcount</span><br><span class="line">print(avgfee)</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.bilibili.com/video/av74106411/?p=75" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>现代计算机上面，CPU是多核的， 每个核都可以执行代码。</p><p>要运行程序里面的代码，操作系统就会分配一个CPU核心去执行该代码。</p><p>有的时候，我们希望，能够让更多的CPU核心同时执行我们的程序里面的一些代码。</p><p>假如，我们程序里面有个名为 compress 的函数，执行压缩文件的任务。</p><p>现在有4个大文件，需要压缩。</p><p>如果是一个CPU核心执行这个函数（单线程的程序），压缩一个文件要10秒钟的话， 那么压缩4个文件，就要40秒。</p><p>如果我们能够让 4个CPU核心 <code>同时</code> 执行压缩函数， 理论上就只要 10秒。</p><hr><p>有的时候， 我们有一批任务要执行，而这些任务的执行时间主要耗费在 <code>非CPU计算</code> 上面。</p><p>比如，我们需要到 前程无忧 网站 抓取 python 开发相关的职位信息。</p><p>我们要抓取几百个网页的内容， 执行这些抓取信息的任务的代码，时间主要耗费在等待网站返回信息上面。 等待信息返回的时候CPU是空闲的。</p><p>如果我们像以前那样 在一个线程里面，用一个循环 依次 获取100个网页的信息，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 网页的职位信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">grabOnePage</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'代码发起请求，抓取网页信息，具体代码省略'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pageIdx <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    url = <span class="string">f'https://search.51job.com/list/020000,000000,0000,00,9,99,python,2,<span class="subst">&#123;pageIdx&#125;</span>.html'</span></span><br><span class="line">    grabOnePage(url)</span><br></pre></td></tr></table></figure><p>就会有很长的时间耗费在 等待服务器返回信息上面。</p><p>如果我们能用100个线程，同时运行 获取网页信息的代码， 理论上，可以100倍的减少执行时间。</p><hr><p>要让多个CPU核心同时去执行任务，我们的程序必须 <code>创建多个线程</code> ，让 CPU 执行 多个线程 对应的代码。</p><h2 id="Python代码中创建新线程"><a href="#Python代码中创建新线程" class="headerlink" title="Python代码中创建新线程"></a>Python代码中创建新线程</h2><p><a href="https://www.bilibili.com/video/av74106411/?p=76" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>那么我们的程序代码怎么产生新线程呢？</p><p>应用程序必须 通过操作系统提供的 <strong>系统调用</strong>，请求操作系统分配一个新的线程。</p><p>python3 将 系统调用创建线程 的功能封装在 标准库 threading 中。</p><p>大家来看下面的一段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'主线程执行代码'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 threading 库中导入Thread类</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">(arg1,arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'子线程 开始'</span>)</span><br><span class="line">    print(<span class="string">f'线程函数参数是：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>'</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Thread 类的实例对象， 并且指定新线程的入口函数</span></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行start 方法，就会创建新线程，</span></span><br><span class="line"><span class="comment"># 并且新线程会去执行入口函数里面的代码。</span></span><br><span class="line"><span class="comment"># 这时候 这个进程 有两个线程了。</span></span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程的代码执行 子线程对象的join方法，</span></span><br><span class="line"><span class="comment"># 就会等待子线程结束，才继续执行下面的代码</span></span><br><span class="line">thread.join()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>运行该程序，解释器执行到下面代码时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>)</span><br><span class="line">                )</span><br></pre></td></tr></table></figure><p>创建了一个Thread实例对象，其中，Thread类的初始化参数 有两个</p><p>target参数 是指定新线程的 <strong>入口函数</strong>， 新线程创建后就会 执行该入口函数里面的代码，</p><p>args 指定了 传给 入口函数threadFunc 的参数。 线程入口函数 参数，必须放在一个元组里面，里面的元素依次作为入口函数的参数。</p><p>注意，上面的代码只是创建了一个Thread实例对象， 但这时，<strong>新的线程还没有创建</strong>。</p><p>要创建线程，必须要调用 Thread 实例对象的 <code>start</code>方法 。也就是执行完下面代码的时候</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码。</p><p>有的时候， 一个线程需要等待其它的线程结束，比如需要根据其他线程运行结束后的结果进行处理。</p><p>这时可以使用 Thread对象的 <code>join</code> 方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.join()</span><br></pre></td></tr></table></figure><p>如果一个线程A的代码调用了 对应线程B的Thread对象的 <code>join</code> 方法，线程A就会停止继续执行代码，等待线程B结束。 线程B结束后，线程A才继续执行后续的代码。</p><p>所以主线程在执行上面的代码时，就暂停在此处， 一直要等到 新线程执行完毕，退出后，才会继续执行后续的代码。</p><p>关于多线程join的用途，白月黑羽在和一个VIP实战班学员交流中 有 这样的比喻，如下图所示</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200509150215_68.png" alt="image"></p><p>join通常用于 主线程把任务分配给几个子线程，等待子线程完成工作后，需要对他们任务处理结果进行再处理。</p><p>就好像一个领导把任务分给几个员工，等几个员工完成工作后，他需要收集他们的提高报告，进行后续处理。</p><p>这种情况，主线程必须子线程完成才能进行后续操作，所以join就是 等待参数对应的线程完成，才返回。</p><hr><p>不少学员 创建线程对象 的时候，会写成下面这样</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))</span><br></pre></td></tr></table></figure><p>为什么这样写不对？和下面的写法有什么区别？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/av65489865/?p=9" target="_blank" rel="noopener">点击这里观看白月黑羽和 VIP 学员的视频交流讲解</a></p><h2 id="共享数据的访问控制"><a href="#共享数据的访问控制" class="headerlink" title="共享数据的访问控制"></a>共享数据的访问控制</h2><p><a href="https://www.bilibili.com/video/av74106411/?p=77" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>做多线程开发，经常遇到这样的情况：多个线程里面的代码 需要访问 同一个 公共的数据对象。</p><p>这个公共的数据对象可以是任何类型， 比如一个 列表、字典、或者自定义类的对象。</p><p>有的时候，程序 需要 防止线程的代码 同时操作 公共数据对象。 否则，就有可能导致 数据的访问互相冲突影响。</p><p>请看一个例子。</p><p>我们用一个简单的程序模拟一个银行系统，用户可以往自己的帐号上存钱。</p><p>对应代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line">    print(<span class="string">f'子线程 <span class="subst">&#123;theadidx&#125;</span> 结束'</span>)</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码中，一起执行</p><p>开始的时候， 该帐号的余额为0，随后我们启动了10个线程， 每个线程都deposit函数，往帐号byhy上存1元钱。</p><p>可以预期，执行完程序后，该帐号的余额应该为 10。</p><p>然而，我们运行程序后，发现结果如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为什么是 1 呢？ 而不是 10 呢？</p><hr><p>如果在我们程序代码中，只有一个线程，如下所示</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    deposit (idx,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>代码都是 <code>串行</code> 执行的。 不存在多线程同时访问 bank对象 的问题，运行结果一切都是正常的。</p><p>现在我们程序代码中，有多个线程，并且在这个几个线程中都会去调用 deposit，就有可能同时操作这个bank对象，就有可能出一个线程覆盖另外一个线程的结果的问题。</p><p>这时，可以使用 threading库里面的锁对象 <strong>Lock</strong> 去保护。</p><p>我们修改多线程代码，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bankLock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    <span class="comment"># 操作共享数据前，申请获取锁</span></span><br><span class="line">    bankLock.acquire()</span><br><span class="line">    </span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line">    print(<span class="string">f'子线程 <span class="subst">&#123;theadidx&#125;</span> 结束'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 操作完共享数据后，申请释放锁</span></span><br><span class="line">    bankLock.release()</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>执行一下，结果如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>正确了。</p><p>Lock 对象的acquire方法 是申请锁。</p><p>每个线程在 操作共享数据对象之前，都应该 申请获取操作权，也就是 调用该 共享数据对象对应的锁对象的acquire方法。</p><p>如果线程A 执行如下代码，调用acquire方法的时候，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bankLock.acquire()</span><br></pre></td></tr></table></figure><p>别的线程B 已经申请到了这个锁， 并且还没有释放，那么 线程A的代码就在此处 等待 线程B 释放锁，不去执行后面的代码。</p><p>直到线程B 执行了锁的 release 方法释放了这个锁， 线程A 才可以获取这个锁，就可以执行下面的代码了。</p><p>如果这时线程B 又执行 这个锁的acquire方法， 就需要等待线程A 执行该锁对象的release方法释放锁， 否则也会等待，不去执行后面的代码。</p><p>具体参考视频里面的讲解。</p><h2 id="daemon线程"><a href="#daemon线程" class="headerlink" title="daemon线程"></a>daemon线程</h2><p>大家执行下面的代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line">thread = Thread(target=threadFunc)</span><br><span class="line">thread.start()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>可以发现，主线程先结束，要过个2秒钟，等子线程运行完，整个程序才会结束退出。</p><p>因为：</p><p>Python程序中当所有的 <code>非daemon线程</code> 结束了，整个程序才会结束</p><p>主线程是非daemon线程，启动的子线程缺省也是 非daemon线程 线程。</p><p>所以，要等到 主线程和子线程 都结束，程序才会结束。</p><p>我们可以在创建线程的时候，设置daemon参数值为True，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                daemon=<span class="literal">True</span> <span class="comment"># 设置新线程为daemon线程</span></span><br><span class="line">                )</span><br><span class="line">thread.start()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>再次运行，可以发现，只要主线程结束了，整个程序就结束了。因为只有主线程是非daemon线程。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Python 官方解释器 的每个线程要获得执行权限，必须获取一个叫 GIL （全局解释器锁） 的东西。</p><p>这就导致了 Python 的多个线程 其实 并不能同时使用 多个CPU核心。</p><p>所以如果是计算密集型的任务，不能采用多线程的方式。</p><p>大家可以运行一下如下代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="comment"># 启动10个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Thread(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>运行后，打开任务管理器，可以发现 即使是启动了10个线程，依然只能占用一个CPU核心的运算能力。</p><p>如下图所示，我的电脑有4个核心，这个Python进程占用了1个核心的运行能力，所以下图显示25，表示 25% ，也就是 1/4的CPU占用率</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200902191303_10.png" alt="image"></p><p>如果需要利用电脑多个CPU核心的运算能力，可以使用Python的多进程库，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Process(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>运行后，打开任务管理器，可以发现 有3个Python进程，其中主进程CPU占用率为0，两个子进程CPU各占满了一个核心的运算能力。</p><p>如下图所示</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200902191641_40.png" alt="image"></p><p>仔细看上面的代码，可以发现和多线程的使用方式非常类似。</p><p>还有一个问题，主进程如何获取 子进程的 运算结果呢？</p><p>可以使用多进程库 里面的 Manage 对象，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Manager</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(taskno,return_dict)</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 存放计算结果到共享对象中</span></span><br><span class="line">    return_dict[taskno] = taskno</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line">    <span class="comment"># 创建 类似字典的 跨进程 共享对象</span></span><br><span class="line">    return_dict = manager.dict()</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=f, args=(i,return_dict))</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'get result...'</span>)</span><br><span class="line">    <span class="comment"># 从共享对象中取出其他进程的计算结果</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> return_dict.items():</span><br><span class="line">        <span class="keyword">print</span> (k,v)</span><br></pre></td></tr></table></figure><p>（个人收藏用，转自<a href="http://www.python3.vip，强烈安利这个网站）" target="_blank" rel="noopener">http://www.python3.vip，强烈安利这个网站）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习</title>
      <link href="/ArthurDream/2020/09/26/Linux%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/09/26/Linux%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux系统目录结构说明"><a href="#Linux系统目录结构说明" class="headerlink" title="Linux系统目录结构说明"></a><strong>Linux系统目录结构说明</strong></h1><p>（本文内容摘自<a href="https://www.runoob.com/" target="_blank" rel="noopener">菜鸟教程</a>）</p><p>登录系统后，在当前命令窗口下输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure><p>会看到如下图所示:</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/06/4_20.png" alt="img"></p><p>树状目录结构：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Linux文件树.png" alt="img"></p><p>以下是对这些目录的解释：</p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的程序和指令</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p></li></ul><p><strong>账户：</strong></p><ul><li><p><strong>/root</strong>：系统管理员的用户主目录。</p></li><li><p><strong>/home</strong>：用户的主目录，以用户的账号命名的。</p></li><li><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li></ul><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul><h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组</p><p>第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中，第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><strong>绝对路径：</strong><br>路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li><li><strong>相对路径：</strong><br>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！</li></ul><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录及文件名</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~]# ls [--color&#x3D;&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~]# ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将家目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#使用 mkdir 命令创建 runoob 目录</span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"></span><br><span class="line">#使用绝对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd &#x2F;root&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line">#使用相对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd .&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 &#x2F;root 这个目录</span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"># 表示去到目前的上一级目录，亦即是 &#x2F;root 的上一级目录的意思；</span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# pwd [-P]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# pwd</span><br><span class="line">&#x2F;root   &lt;&#x3D;&#x3D; 显示出目录啦～</span><br></pre></td></tr></table></figure><p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;var&#x2F;mail   &lt;&#x3D;&#x3D;注意，&#x2F;var&#x2F;mail是一个连结档</span><br><span class="line">[root@www mail]# pwd</span><br><span class="line">&#x2F;var&#x2F;mail         &lt;&#x3D;&#x3D;列出目前的工作目录</span><br><span class="line">[root@www mail]# pwd -P</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;mail   &lt;&#x3D;&#x3D;怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@www mail]# ls -ld &#x2F;var&#x2F;mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 Sep  4 17:54 &#x2F;var&#x2F;mail -&gt; spool&#x2F;mail</span><br><span class="line"># 看到这里应该知道为啥了吧？因为 &#x2F;var&#x2F;mail 是连结档，连结到 &#x2F;var&#x2F;spool&#x2F;mail </span><br><span class="line"># 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</span><br></pre></td></tr></table></figure><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到/tmp底下尝试创建数个新目录看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# mkdir test    &lt;&#x3D;&#x3D;创建一名为 test 的新目录</span><br><span class="line">[root@www tmp]# mkdir test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">mkdir: cannot create directory &#96;test1&#x2F;test2&#x2F;test3&#x2F;test4&#39;: </span><br><span class="line">No such file or directory       &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！</span><br><span class="line">[root@www tmp]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br></pre></td></tr></table></figure><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx—x—x</strong> 的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# mkdir -m 711 test2</span><br><span class="line">[root@www tmp]# ls -l</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx—x—x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li></ul><p>删除 runoob 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# rmdir runoob&#x2F;</span><br></pre></td></tr></table></figure><p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# ls -l   &lt;&#x3D;&#x3D;看看有多少目录存在？</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br><span class="line">[root@www tmp]# rmdir test   &lt;&#x3D;&#x3D;可直接删除掉，没问题</span><br><span class="line">[root@www tmp]# rmdir test1  &lt;&#x3D;&#x3D;因为尚有内容，所以无法删除！</span><br><span class="line">rmdir: &#96;test1&#39;: Directory not empty</span><br><span class="line">[root@www tmp]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">[root@www tmp]# ls -l        &lt;&#x3D;&#x3D;您看看，底下的输出中test与test1不见了！</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">[root@www ~]# cp -i ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">cp: overwrite &#96;&#x2F;tmp&#x2F;bashrc&#39;? n  &lt;&#x3D;&#x3D;n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# rm -i bashrc</span><br><span class="line">rm: remove regular file &#96;bashrc&#39;? y</span><br></pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# cp ~&#x2F;.bashrc bashrc</span><br><span class="line">[root@www tmp]# mkdir mvtest</span><br><span class="line">[root@www tmp]# mv bashrc mvtest\</span><br></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2，修改文件也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# mv mvtest mvtest2</span><br></pre></td></tr></table></figure><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 <em>man [命令]</em>来查看各个命令的使用文档，如 ：man cp。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 /etc/issue 这个文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat &#x2F;etc&#x2F;issue</span><br><span class="line">CentOS release 6.4 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# tac &#x2F;etc&#x2F;issue</span><br><span class="line"></span><br><span class="line">Kernel \r on an \m</span><br><span class="line">CentOS release 6.4 (Final)</span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 /etc/issue 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl &#x2F;etc&#x2F;issue</span><br><span class="line">     1  CentOS release 6.4 (Final)</span><br><span class="line">     2  Kernel \r on an \m</span><br></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# more &#x2F;etc&#x2F;man_db.config </span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%)  &lt;&#x3D;&#x3D; 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# less &#x2F;etc&#x2F;man.config</span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   &lt;&#x3D;&#x3D; 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# head &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# head -n 20 &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] 文件</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# tail &#x2F;etc&#x2F;man.config</span><br><span class="line"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span><br><span class="line">[root@www ~]# tail -n 20 &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure><h1 id="Linux-vi-vim"><a href="#Linux-vi-vim" class="headerlink" title="Linux vi/vim"></a>Linux vi/vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><hr><h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p>vim 键盘图：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" alt="img"></p><hr><h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png" alt="img"></p><hr><h2 id="vi-vim-使用实例"><a href="#vi-vim-使用实例" class="headerlink" title="vi/vim 使用实例"></a>vi/vim 使用实例</h2><h3 id="使用-vi-vim-进入一般模式"><a href="#使用-vi-vim-进入一般模式" class="headerlink" title="使用 vi/vim 进入一般模式"></a>使用 vi/vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/07/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p><h3 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/07/1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p><h3 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><h3 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/07/B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><hr><h2 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><div class="table-container"><table><thead><tr><th style="text-align:left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td style="text-align:left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td style="text-align:left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td style="text-align:left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td style="text-align:left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td style="text-align:left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td style="text-align:left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td style="text-align:left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td style="text-align:left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td style="text-align:left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td style="text-align:left">n<space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td style="text-align:left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td style="text-align:left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td style="text-align:left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td style="text-align:left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td style="text-align:left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td style="text-align:left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td style="text-align:left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td style="text-align:left">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td style="text-align:left">搜索替换</td><td></td></tr><tr><td style="text-align:left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td style="text-align:left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td style="text-align:left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td style="text-align:left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td style="text-align:left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td style="text-align:left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td style="text-align:left">删除、复制与贴上</td><td></td></tr><tr><td style="text-align:left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td style="text-align:left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td style="text-align:left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td style="text-align:left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td style="text-align:left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td style="text-align:left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td style="text-align:left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td style="text-align:left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td style="text-align:left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td style="text-align:left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td style="text-align:left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td style="text-align:left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td style="text-align:left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td style="text-align:left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td style="text-align:left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td style="text-align:left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td style="text-align:left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td style="text-align:left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td style="text-align:left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table></div><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><div class="table-container"><table><thead><tr><th style="text-align:left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td style="text-align:left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td style="text-align:left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td style="text-align:left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td style="text-align:left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td style="text-align:left">上面这些按键中，在 vi 画面的左下角处会出现『—INSERT—』或『—REPLACE—』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td style="text-align:left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table></div><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><div class="table-container"><table><thead><tr><th style="text-align:left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td style="text-align:left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td style="text-align:left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td style="text-align:left">:q</td><td>离开 vi (常用)</td></tr><tr><td style="text-align:left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td style="text-align:left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td style="text-align:left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td style="text-align:left">ZQ</td><td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td></tr><tr><td style="text-align:left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td style="text-align:left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td style="text-align:left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td style="text-align:left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td style="text-align:left">vim 环境的变更</td><td></td></tr><tr><td style="text-align:left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td style="text-align:left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table></div><p>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p><h1 id="Linux-yum-命令"><a href="#Linux-yum-命令" class="headerlink" title="Linux yum 命令"></a>Linux yum 命令</h1><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p><p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><h3 id="yum-语法"><a href="#yum-语法" class="headerlink" title="yum 语法"></a>yum 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><hr><h2 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h2><ul><li>\1. 列出所有可更新的软件清单命令：<strong>yum check-update</strong></li><li>\2. 更新所有软件命令：<strong>yum update</strong></li><li>\3. 仅安装指定的软件命令：<strong>yum install <package_name></strong></li><li>\4. 仅更新指定的软件命令：<strong>yum update <package_name></strong></li><li>\5. 列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>\6. 删除软件包命令：<strong>yum remove <package_name></strong></li><li>\7. 查找软件包命令：<strong>yum search <keyword></strong></li><li>\8. 清除缓存命令:<ul><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul></li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h3><p>安装 pam-devel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# yum install pam-devel</span><br><span class="line">Setting up Install Process</span><br><span class="line">Parsing package install arguments</span><br><span class="line">Resolving Dependencies  &lt;&#x3D;&#x3D;先检查软件的属性相依问题</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be updated</span><br><span class="line">--&gt; Processing Dependency: pam &#x3D; 0.99.6.2-4.el5 for package: pam-devel</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package pam.i386 0:0.99.6.2-4.el5 set to be updated</span><br><span class="line">filelists.xml.gz          100% |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| 1.6 MB    00:05</span><br><span class="line">filelists.xml.gz          100% |&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;| 138 kB    00:00</span><br><span class="line">-&gt; Finished Dependency Resolution</span><br><span class="line">……(省略)</span><br></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><p>移除 pam-devel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# yum remove pam-devel</span><br><span class="line">Setting up Remove Process</span><br><span class="line">Resolving Dependencies  &lt;&#x3D;&#x3D;同样的，先解决属性相依的问题</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be erased</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> Package                 Arch       Version          Repository        Size</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Removing:</span><br><span class="line"> pam-devel               i386       0.99.6.2-4.el5   installed         495 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Install      0 Package(s)</span><br><span class="line">Update       0 Package(s)</span><br><span class="line">Remove       1 Package(s)  &lt;&#x3D;&#x3D;还好，并没有属性相依的问题，单纯移除一个软件</span><br><span class="line"></span><br><span class="line">Is this ok [y&#x2F;N]: y</span><br><span class="line">Downloading Packages:</span><br><span class="line">Running rpm_check_debug</span><br><span class="line">Running Transaction Test</span><br><span class="line">Finished Transaction Test</span><br><span class="line">Transaction Test Succeeded</span><br><span class="line">Running Transaction</span><br><span class="line">  Erasing   : pam-devel                    ######################### [1&#x2F;1]</span><br><span class="line"></span><br><span class="line">Removed: pam-devel.i386 0:0.99.6.2-4.el5</span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例 3"></a>实例 3</h3><p>利用 yum 的功能，找出以 pam 为开头的软件名称有哪些？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# yum list pam*</span><br><span class="line">Installed Packages</span><br><span class="line">pam.i386                  0.99.6.2-3.27.el5      installed</span><br><span class="line">pam_ccreds.i386           3-5                    installed</span><br><span class="line">pam_krb5.i386             2.2.14-1               installed</span><br><span class="line">pam_passwdqc.i386         1.0.2-1.2.2            installed</span><br><span class="line">pam_pkcs11.i386           0.5.3-23               installed</span><br><span class="line">pam_smb.i386              1.1.7-7.2.1            installed</span><br><span class="line">Available Packages &lt;&#x3D;&#x3D;底下则是『可升级』的或『未安装』的</span><br><span class="line">pam.i386                  0.99.6.2-4.el5         base</span><br><span class="line">pam-devel.i386            0.99.6.2-4.el5         base</span><br><span class="line">pam_krb5.i386             2.2.14-10              base</span><br></pre></td></tr></table></figure><hr><h2 id="国内-yum-源"><a href="#国内-yum-源" class="headerlink" title="国内 yum 源"></a>国内 yum 源</h2><p>网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。</p><p>将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)</p><ul><li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo" target="_blank" rel="noopener">CentOS5</a> ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo" target="_blank" rel="noopener">CentOS6</a> ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">CentOS7</a> ：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS6-Base-163.repo</span><br><span class="line">mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>除了网易之外，国内还有其他不错的 yum 源，比如中科大和搜狐。</p><p>中科大的 yum 源，安装方法查看：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/centos" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/centos</a></p><p>sohu 的 yum 源安装方法查看: <a href="http://mirrors.sohu.com/help/centos.html" target="_blank" rel="noopener">http://mirrors.sohu.com/help/centos.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSMA/CA与CSMA/CD的异同</title>
      <link href="/ArthurDream/2020/09/26/CSMA-CA%E4%B8%8ECSMA-CD%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/ArthurDream/2020/09/26/CSMA-CA%E4%B8%8ECSMA-CD%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、CSMA-CD-概述"><a href="#一、CSMA-CD-概述" class="headerlink" title="一、CSMA/CD 概述"></a>一、CSMA/CD 概述</h2><p>​    CSMA/CD协议（Carrier Sense Multiple Access with Collision Detection）即<strong>载波帧听，多路访问/冲突检测</strong></p><p>​    <strong>载波侦听</strong>：多个计算机在<strong>发送数据帧前，首先帧听是否空闲</strong>，如果空闲，则发送数据帧；否则等待，继续帧听直到信道空闲。</p><p>   <strong>多路访问</strong>：许多计算机以<strong>多点接入</strong>方式连接在一根总线上，都有访问总线的权利。</p><h2 id="二、CSMA-CD控制方式原理"><a href="#二、CSMA-CD控制方式原理" class="headerlink" title="二、CSMA/CD控制方式原理"></a>二、CSMA/CD控制方式原理</h2><p>​    各工作站在发送数据前，需<u>先侦听信道是否空闲</u>。若空闲，则立即发送数据；若信道忙碌，则等待一段时间至信道中的信息传输结束后再发送数据；若在上一段信息发送结束后，同时有两个或两个以上的节点都提出发送请求，则判定为冲突；<strong>若侦听到冲突，则所有节点立即停止发送数据，等待一段随机时间，再重新尝试发送</strong>。如下图所示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://www.wonggang.com/wp-content/uploads/2018/05/152346131339817c52c7c5e.gif" alt="CSMA/CD"></p><p>CSMA/CD控制方式作用: 提供寻址和媒体存取的控制方式，使得不同设备或网络上的节点可以在多点的网络上通信而不相互冲突。</p><h2 id="三、CSMA-CD-特点"><a href="#三、CSMA-CD-特点" class="headerlink" title="三、CSMA/CD 特点"></a>三、CSMA/CD 特点</h2><p>   1、 使用 CSMA/CD 协议的以太网不能进行全双工通信,而只能进行双向交替通信（半双工通信）。<br>   2、 计算机发送数据帧之后的一小段时间内，存在着遭遇冲突的可能性。<br>   3、 冲突不确定性使整个以太网平均数据率远小于以太网最高数据率。</p><p>​                                              <strong>部分2</strong></p><hr><h2 id="一、CSMA-CA"><a href="#一、CSMA-CA" class="headerlink" title="一、CSMA/CA"></a>一、CSMA/CA</h2><p>   CSMA/CA （Carrier Sense Multiple Access with Collision Avoidance） 即<strong>载波侦听多路访问／冲突避免</strong>。</p><p>采用该协议要求设备要主动<strong>避免冲突</strong>而非被动侦测的方式来解决冲突问题。避免冲突的方法主要有两个：<br>    1、监听到信道空闲时，并不是立即发送，而是<strong>等待一段时间</strong>再发送数据。<br>    2、先发送一个很小的信道侦测帧RTS，如果收到最近的接入点返回的CTS，就认为信道是空闲的，然后再发送数据</p><p>协议的主要流程如下：<br>   1、 首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。<br>   2、 接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。<br>   3、 发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，再发送数据。</p><p>二、CSMA/CD 与CSMA/CA  两者区别</p><p>   1、 CSMA/CD主要着眼点在冲突的侦测，当侦测到冲突时，进行相应的处理，要求设备能一边侦测一边发送数据。<br>    2、CSMA/CA主要着眼点在冲突的避免，协议里也看到经常是等待一段时间再做动作，通过退避尽量去避免冲突，还有就是先发送一些特别小的信道侦测帧来测试信道是否有冲突。</p><p>三、应用</p><p>​     CSMA/CD主要适用<strong>以太网</strong>。<br>​     CSMA/CA主要适用<strong>无线局域网</strong>。</p><p>​                                              <strong>部分2</strong></p><p>参考：</p><p>1、<a href="https://blog.csdn.net/lixuande19871015/article/details/78783740" target="_blank" rel="noopener">https://blog.csdn.net/lixuande19871015/article/details/78783740</a></p><p>2、<a href="http://www.wonggang.com/8126.html" target="_blank" rel="noopener">http://www.wonggang.com/8126.html</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX 知识复习(转)</title>
      <link href="/ArthurDream/2020/08/03/Ajax%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/08/03/Ajax%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AJAX-简介"><a href="#AJAX-简介" class="headerlink" title="AJAX 简介"></a>AJAX 简介</h2><hr><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><hr><h2 id="什么是-AJAX-？"><a href="#什么是-AJAX-？" class="headerlink" title="什么是 AJAX ？"></a>什么是 AJAX ？</h2><p>AJAX = 异步 JavaScript 和 XML。</p><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p><p><a href="https://arthurblog.oss-cn-beijing.aliyuncs.com/Ajax1.png" target="_blank" rel="noopener">https://arthurblog.oss-cn-beijing.aliyuncs.com/Ajax1.png</a></p><h2 id="AJAX是基于现有的Internet标准"><a href="#AJAX是基于现有的Internet标准" class="headerlink" title="AJAX是基于现有的Internet标准"></a>AJAX是基于现有的Internet标准</h2><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p><ul><li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li><li>JavaScript/DOM (信息显示/交互)</li><li>CSS (给数据定义样式)</li><li>XML (作为转换数据的格式)</li></ul><h2 id="AJAX-XMLHttpRequest对象"><a href="#AJAX-XMLHttpRequest对象" class="headerlink" title="AJAX - XMLHttpRequest对象"></a>AJAX - XMLHttpRequest对象</h2><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p><p>创建 XMLHttpRequest 对象的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=new XMLHttpRequest();</span><br></pre></td></tr></table></figure><h2 id="AJAX-向服务器发送请求"><a href="#AJAX-向服务器发送请求" class="headerlink" title="AJAX - 向服务器发送请求"></a>AJAX - 向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open("GET","ajax_info.txt",true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">open(<em>method</em>,<em>url</em>,<em>async</em>)</td><td style="text-align:left">规定请求的类型、URL 以及是否异步处理请求。<strong><em>method</em></strong>：请求的类型，GET 或 POST；<strong><em>url</em></strong>：文件在服务器上的位置；<strong><em>async</em></strong>：true（异步）或 false（同步）</td></tr><tr><td style="text-align:left">send(<em>string</em>)</td><td style="text-align:left">将请求发送到服务器。<strong><em>string</em></strong>：仅用于 POST 请求</td></tr></tbody></table></div><h2 id="用GET-还是-POST？"><a href="#用GET-还是-POST？" class="headerlink" title="用GET 还是 POST？"></a>用GET 还是 POST？</h2><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h2 id="AJAX-服务器响应"><a href="#AJAX-服务器响应" class="headerlink" title="AJAX - 服务器响应"></a>AJAX - 服务器响应</h2><h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">responseText</td><td style="text-align:left">获得字符串形式的响应数据。</td></tr><tr><td style="text-align:left">responseXML</td><td style="text-align:left">获得 XML 形式的响应数据。</td></tr></tbody></table></div><h2 id="responseText-属性"><a href="#responseText-属性" class="headerlink" title="responseText 属性"></a>responseText 属性</h2><p>如果来自服务器的响应并非 XML，使用 responseText 属性。</p><p>responseText 属性返回字符串形式的响应，因此可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById("myDiv").innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure><h2 id="responseXML-属性"><a href="#responseXML-属性" class="headerlink" title="responseXML 属性"></a>responseXML 属性</h2><p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，使用 responseXML 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlDoc&#x3D;xmlhttp.responseXML;</span><br><span class="line">txt&#x3D;&quot;&quot;;</span><br><span class="line">x&#x3D;xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);</span><br><span class="line">for (i&#x3D;0;i&lt;x.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    txt&#x3D;txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;txt;</span><br></pre></td></tr></table></figure><p>（节选自菜鸟教程）</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON 知识复习</title>
      <link href="/ArthurDream/2020/07/30/JSON%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/07/30/JSON%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h2><p>JSON 是用于存储和传输数据的格式。</p><p>JSON 通常用于服务端向网页传递数据 。</p><h2 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON?"></a>什么是 JSON?</h2><ul><li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li><li>JSON 是一种轻量级的数据交换格式。</li><li>JSON是独立的语言 <strong>*</strong></li><li>JSON 易于理解。</li></ul><ul><li>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。 文本可以被任何编程语言读取及作为数据格式传递。</li></ul><h2 id="JSON-格式化后为-JavaScript-对象"><a href="#JSON-格式化后为-JavaScript-对象" class="headerlink" title="JSON 格式化后为 JavaScript 对象"></a>JSON 格式化后为 JavaScript 对象</h2><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的。</p><p>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象。</p><h2 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h2><ul><li>数据为 键/值 对。</li><li>数据由逗号分隔。</li><li>大括号保存对象</li><li>方括号保存数组</li></ul><h2 id="JSON-数据-一个名称对应一个值"><a href="#JSON-数据-一个名称对应一个值" class="headerlink" title="JSON 数据 - 一个名称对应一个值"></a>JSON 数据 - 一个名称对应一个值</h2><p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p><p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;:&quot;Arthur&quot;</span><br></pre></td></tr></table></figure><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 对象保存在大括号内。</p><p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"name":"Baidu", "url":"www.baidu.com"&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h2><p>JSON 数组保存在中括号内。</p><p>就像在 JavaScript 中, 数组可以包含对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"sites":[    </span><br><span class="line">&#123;"name":"Baidu", "url":"www.baidu.com"&#125;,     </span><br><span class="line">&#123;"name":"Google", "url":"www.google.com"&#125;,    </span><br><span class="line">&#123;"name":"Taobao", "url":"www.taobao.com"&#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在以上实例中，对象 “sites” 是一个数组，包含了三个对象。</p><p>每个对象为站点的信息（网站名和网站地址）。</p><h2 id="JSON-字符串转换为-JavaScript-对象"><a href="#JSON-字符串转换为-JavaScript-对象" class="headerlink" title="JSON 字符串转换为 JavaScript 对象"></a>JSON 字符串转换为 JavaScript 对象</h2><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据。</p><p>简单起见，我们网页中直接设置 JSON 字符串 </p><p>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = '&#123; "sites" : [' +</span><br><span class="line">'&#123; "name":"Baidu" , "url":"www.baidu.com" &#125;,' +</span><br><span class="line">'&#123; "name":"Google" , "url":"www.google.com" &#125;,' +</span><br><span class="line">'&#123; "name":"Taobao" , "url":"www.taobao.com" &#125; ]&#125;';</span><br></pre></td></tr></table></figure><p><strong>然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = JSON.parse(text);</span><br></pre></td></tr></table></figure><p>最后，在你的页面中使用新的 JavaScript 对象：</p><p><strong>实例代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSON实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>为 JSON 字符串创建对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> text = <span class="string">'&#123; "sites" : ['</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Baidu" , "url":"www.baidu.com" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Google" , "url":"www.google.com" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Taobao" , "url":"www.taobao.com" &#125; ]&#125;'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">obj = <span class="built_in">JSON</span>.parse(text);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = obj.sites[<span class="number">1</span>].name + <span class="string">" "</span> + obj.sites[<span class="number">1</span>].url;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:\Users\段梦宇\AppData\Roaming\Typora\typora-user-images\image-20200802164743836.png" alt="image-20200802164743836"></p><h2 id="JavaScript-对象转换为JSON-字符串"><a href="#JavaScript-对象转换为JSON-字符串" class="headerlink" title="JavaScript 对象转换为JSON 字符串"></a>JavaScript 对象转换为JSON 字符串</h2><p>JSON 通常用于与服务端交换数据。</p><p>在向服务器发送数据时一般是字符串。</p><p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p><p><strong>语法:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer[, space]])</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p>value:</p><p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p></li><li><p>replacer:</p><p>可选。用于转换结果的函数或数组。</p><p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p><p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p></li><li><p>space:</p><p>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p></li></ul><h2 id="JavaScript-对象转换"><a href="#JavaScript-对象转换" class="headerlink" title="JavaScript 对象转换"></a>JavaScript 对象转换</h2><p>例如我们向服务器发送以下数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; "name":"baidu", "alexa":10000, "site":"www.baidu.com"&#125;;</span><br></pre></td></tr></table></figure><p>我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myJSON = JSON.stringify(obj);</span><br></pre></td></tr></table></figure><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><p><strong>实例代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>实例代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 对象转换为 JSON 字符串<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> obj = &#123; <span class="string">"name"</span>:<span class="string">"baidu"</span>, <span class="string">"alexa"</span>:<span class="number">10000</span>, <span class="string">"site"</span>:<span class="string">"www.baidu.com"</span>&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(obj);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:\Users\段梦宇\AppData\Roaming\Typora\typora-user-images\image-20200802165250473.png" alt="image-20200802165250473"></p><h2 id="JavaScript-数组转换"><a href="#JavaScript-数组转换" class="headerlink" title="JavaScript 数组转换"></a>JavaScript 数组转换</h2><p>我们也可以将 JavaScript 数组转换为 JSON 字符串：</p><p><strong>实例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ "Google", "Runoob", "Taobao", "Facebook" ];</span><br><span class="line">var myJSON = JSON.stringify(arr);</span><br></pre></td></tr></table></figure><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>实例代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 数组转换为 JSON 对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> arr = [ <span class="string">"Google"</span>, <span class="string">"Baidu"</span>, <span class="string">"Taobao"</span>, <span class="string">"Facebook"</span> ];</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(arr);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:\Users\段梦宇\AppData\Roaming\Typora\typora-user-images\image-20200802165434899.png" alt="image-20200802165434899"></p><p>（内容及部分代码引自菜鸟教程，非常好的自学网站，强烈推荐！）</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自信鸡汤</title>
      <link href="/ArthurDream/2020/07/18/%E8%87%AA%E4%BF%A1%E9%B8%A1%E6%B1%A4/"/>
      <url>/ArthurDream/2020/07/18/%E8%87%AA%E4%BF%A1%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何变得自信起来？"><a href="#如何变得自信起来？" class="headerlink" title="如何变得自信起来？"></a>如何变得自信起来？</h2><p>（摘自知乎 心理指导）</p><p>自信，就是对自己能够达到某种目标的乐观、充分估计。美国作家爱默生说：“自信是成功的第一秘诀。”可以说，拥有自信就拥有无限机会。那么如何增强自信呢？</p><p>增强自信的第一个方法：<strong>关注自己的优点</strong>。在纸上列下十个优点，不论是哪方面（细心、眼睛好看等等，多多益善），在从事各种活动时，想想这些优点，并告诉自己有什么优点。这样有助你提升从事这些活动的自信，这叫做“自信的蔓延效应”。这一效应对提升自信效果很好。</p><p>增强自信的第二个方法：<strong>与自信的人多接触</strong>。“近朱者赤，近墨者黑”这一点对增强自信同样有效。</p><p>增强自信的第三个方法：<strong>自我心理暗示</strong>，不断对自己进行正面心理强化，避免对自己进行负面强化。一旦自己有所进步（不论多小）就对自己说：“我能行！”、“我很棒！”、“我能做得更好！”等等，这将不断提升自己的信心。</p><p>增强自信的第四个方法：<strong>树立自信的外部形象</strong>。首先，保持整洁、得体的仪表，有利于增强一个人的自信；其次，举止自信，如行路目视前方等，刚开始可能不习惯，但过一段时间后就会有发自内心的自信；另外，注意锻炼、保持健美的体形对增强自信也很有帮助。</p><p>增强自信的第五个方法：<strong>不可谦虚过度</strong>。谦虚是必要的，但不可过度，过分贬低自己对自信心的培养是极为不利的。</p><p>增强自信的第六个方法：<strong>学会微笑</strong>。微笑会增加幸福感，进而增强自信。</p><p>增强自信的第七个方法：<strong>扬长避短</strong>。在学习、生活、工作中，抓住机会展现自己的优势、特长，同时注意弥补自己的不足，不断进步，肯定能增强自信。</p><p>增强自信的第八个方法：<strong>阅读名人传记</strong>，因为很多知名人士成名前的自身资质、外部环境并不好，如果多看一些这方面的材料有助于提升自信心。</p><p>增强自信的第九个方法：<strong>做好充分准备</strong>。从事某项活动前如果能做好充分准备，那么，在从事这项活动时，必然较为自信，而且这利于顺利完成活动并增强整体自信心。</p><p>增强自信的第十个方法：<strong>给自己定恰当的目标</strong>，并且在目标达成后，定更高的目标。目标不能太高，否则不易达到，如果达不到，对自信心会有所破坏。</p><p>增强自信的第十一个方法：<strong>冒一次险</strong>。当你做了以前不敢做的事以后，你会发现：原来作这事并没有什么了不起！这对提升自信心很有帮助。</p><p>增强自信的第十二个方法：<strong>排除压力</strong>。过重的压力会使自己意志消沉，对自身产生怀疑，从而破坏自信心，学会排除压力对保持原有自信帮助很大。</p><p>增强自信的第十三个方法：<strong>做自己喜欢做的事</strong>。对自己喜欢做的事，因为比较投入，容易取得成功，继而产生成就感，这非常有利于自信心的提高。</p><p>增强自信的第十四个方法：<strong>保持健康</strong>。注意全面的营养、保证身体锻炼、保持快乐的心境，良好的生理、心理状况会使自己产生幸福感，进而产生自信心。</p><p>增强自信的第十五个方法：<strong>尽量依靠自己</strong>。有事尽量依靠自己解决，能不断激发自身的潜力，并且通过一次次的成功，不断提升自信水平。</p><h2 id="真正的自信来源于对自己作为一个人的信心。"><a href="#真正的自信来源于对自己作为一个人的信心。" class="headerlink" title="真正的自信来源于对自己作为一个人的信心。"></a>真正的自信来源于对自己作为一个人的信心。</h2><p><strong>无论成功或是失败，你都能够坦然面对，既不失望、愤怒，也不自责、绝望</strong>。你既不会因成功而忘乎所以，也不会因挫折而感到沮丧和抑郁。你或许会有强烈的愿望，希望自己做得好，表现出色，并为之付出巨大的努力，但在内心里，你能够接受真实的你。自信的真正来源在于自我接纳，无论好坏你都要接纳你自己，真正的友谊与接纳，表现为困境中的自我扶持。</p><p>学会享受成功，告诉自己：“这很棒，我要享受自己的成功。”即使是小的成功，也要学会表扬自己，你越是体验到成功的快乐，你就越会努力追求成功。如果你的努力仅出于恐惧。事情会变得令人厌烦，你要学会用奖励来激励自己，而不是用恐惧来惩罚自己。当你追求成功而不是避免失败时，你启用了大脑完全不同的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程几个术语的理解</title>
      <link href="/ArthurDream/2020/07/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/ArthurDream/2020/07/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-问题空间"><a href="#1-问题空间" class="headerlink" title="1.问题空间"></a>1.问题空间</h3><p>知道什么是 “<strong>问题空间</strong>” 是一个搬砖的必备基础，我们下面来看一下《维基百科》中关于它的定义： 问题空间是问题解决者对一个问题所达到的全部认识状态，它是由问题解决者利用问题所包含的信息和 已储存的信息主动构成的。<br>一个问题一般由三个方面来定义：<strong>初始状态</strong>（开始时的不完全的信息），<strong>目标状态</strong>（你希望获得的信息 或状态），<strong>操作</strong>（从初始状态到目标状态所采取的步骤）。这三个部分加在一起定义了问题空间。</p><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h3><p>这里的 “对象” 不是你的 “对象”，英文单词是 Object，至于为什么翻译成对象我们不去追究，我们需要 知道的是” <strong>Python 中的一切都是对象</strong>“，不管你是字符串，函数还是类，都是对象。 那你可能问了，Python 都是对象有什么用么？简直是太有用了，这说明 Python 是面向对象编程的！ 大佬们对于对象的定义相当高深：一个对象要有自己的状态，行为和唯一的标识；所有相同类型的对象 所具有的结构和行为在它们共同的类中被定义。大佬们的话确实有水平，但是这个定义对于初学者来说 可能不太好理解。<br>其实简言之，对象应该具有属性（就是大佬们说的状态），方法（就是大佬们说的行为）和标识，但是 标识是自动就完成的，所以我们一般不用管它，所以<strong>一个对象主要就是有属性和方法，属性是说这个东 西是什么，方法是说这个东西能做什么。</strong></p><h3 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3.面向对象"></a>3.面向对象</h3><p>面向对象(OOP)，是现在编程的主流。<strong>面向对象编程可以看作是一种在程序中包含各种独立且又互相调 用的对象的思想</strong>，这个和传统正好相反，传统的思想主张将程序直接看作是一系列对计算机下达的指 令，而面向对象编程中的每一个对象都应该能够接受数据，处理数据并且能将数据传达给其它对象，因 此它们每一个都可以看作是一个小型的机器，即对象。<br>目前来说面向对象编程推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。当我们提到 面向对象的时候，它不仅仅是指一种程序设计方法，更多意义上是一种程序开发方式。</p><h3 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h3><p>在目前所流行的高级编程语言中，“类” 是必须要有的，我们先来看《维基百科》中的定义：<br>在面向对象编程中，<strong>类 (class) 是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所 创建的对象共同的属性和方法。</strong><br>对于类更严格点的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这 些对象就被成为该类的实例。类有接口和结构，接口描述了如何通过方法与类及其实例互相操作，而结 构描述了一个实例中数据如何划分为多个属性。<br>支持类的编程语言在支持与类相关的各种特性方面都多多少少有一些微妙的差异。大多数都支持不同形 式的类继承。类的出现，为面向对象编程的三个最重要的特性（封装，继承，多态）提供了实现的手 段。<br>看到这里，你或许有这么一个认识，要面向对象编程就要用到类，虽然不是很严格，但是我们可以这么 说，当然了，反过来的话是不可以的。</p><p><strong>类是对某一群具有同样属性和方法的对象的抽象</strong>，比如长翅膀会飞的的生物，我们把它们统一称为 “鸟”。</p><h3 id="创建一个-“类”"><a href="#创建一个-“类”" class="headerlink" title="创建一个 “类”"></a>创建一个 “类”</h3><p>如何创建一个 “类”，为了更普遍性的说明，我来写一个具有通常类的结构的类，请看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    具有通常类的结构的 Person 类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sex</span><span class="params">(self,sex)</span>:</span></span><br><span class="line">        per_sex = &#123;&#125;</span><br><span class="line">        per_sex[self.name] = sex</span><br><span class="line">        <span class="keyword">return</span> per_sex</span><br></pre></td></tr></table></figure><p>上面的 Person 类是一个很常见的类，下面我来对它就行逐一解释：<br>在 Python3 中所有的类都是 object 的子类，正是因为这个原因，所以不用像 Python2 中那样要把对 object 的继承写出来。class Person：这是在声明创建一个名字是 “Person” 的类，关键词是 class，就和函数的 def 一样。类 的名字按照惯例一般用大写字母开头，如果名字是两个单词，那么两个单词的首字母都要大写，比如 HotDog，当然了如果你不想这样也是可以的，但是我希望你记住 “你的代码是给别人看的”，不要给别 人和自己以后读代码的时候带来麻烦。最后当所有的一切都结束的时候，别忘了在最后带上冒号。<br>接下来就是类里面的代码块，上面例子中类里的代码块看起来很熟悉，都是 def 这个关键词开头的函 数。你是对的，它们就是函数，但是你仔细看一下就会发现，这些函数跟我们在前面学过的函数略微不 同，它们的参数都有 “self”（<strong>要注意 self 是默认的第一个参数</strong>）。这个正是类中函数的特色，是为了跟 我们以前学过的函数区别开来，所以一般在类里的函数我们不叫它们函数，而叫它们 “方法”。所以<strong>当你 听到有人说 “方法” 的时候，不用奇怪，它和函数在本质上是一样的</strong>。</p><p>下面对类里的几个函数做一个简要的介绍。<br>def <strong>init</strong>(self,name)：这是一个特殊的方法，以<strong>双下划线</strong>开头和结尾，这样的方法其实在类里面还有很 多，统一叫它们 “特殊方法”。对于 init() 还有一个别的名字，叫 “构造函数”，也有叫它是 “初始化方法” 的，个人认为第二个更好一点，因为单从字面上来看，它对应的含义应该是初始化。所谓的初始化，就 是让类有一个基本的样子，而不是里面什么也没有，很多事情都要初始化，让事情有一个具体的起点状 态，比如你要吃饭，碗里得先有饭。在用类创建实例的时候，首先执行的是初始化方法。<br>在上面的例子中，初始化方法里的参数除了 self 以外，还有一个 name，在 Person 类被实例化的同 时，要传给它一个值。self.name = name 的意思是建立实例的一个属性，这个属性的名字也是 name，它的值等于参数 name 所传入的值。要注意的是，这里的属性 self.name 和参数 name 是纯属 巧合，你也可以写成 self.aaa = name，只不过这样写会觉得很别扭。<br>接下来的 def get_name(self) 和 def get_sex(self,sex) 是类里面的另外两个方法，这两个方法除了第一 个参数必须是 self 以外，其它跟函数没有什么区别。你只需要注意的是，两个方法中都用到了 self.name，属性的这种调用方式只能在类里面使用。</p><h3 id="“类”-的实例"><a href="#“类”-的实例" class="headerlink" title="“类” 的实例"></a>“类” 的实例</h3><p>类是对象的定义，实例才是真实的东西。比如 “人” 是一个类，但是 “人” 终究不是具体的某个会喘气 的，只有 “rocky” 才是具体的东西，但他是具有 “人” 这个类所定义的属性和方法。“rocky” 就是 “人” 这 个类的实例。<br>我们继续用上面那个类的例子，直接写一下调用这个类的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    boy = Person(<span class="string">'rocky'</span>)</span><br><span class="line">    print(boy.name)</span><br><span class="line">    name = boy.get_name()</span><br><span class="line">    print(name) </span><br><span class="line">    his_sex = boy.get_sex(<span class="string">'男'</span>)</span><br><span class="line">    print(his_sex)</span><br></pre></td></tr></table></figure><p>上面代码中 boy = Person(‘rocky’) 是利用上面的类创建的实例。创建实例的过程就是调用类 Person()， 首先执行的是初始化函数，上述例子中的初始化函数有两个参数，即 self 和 name，其中 self 是默认参 数，不需要传值，name 则需要给它传值，所以用Person(‘rocky’) 的样式。<br>boy 就是一个实例，它有属性和方法，self.name 是它的属性，<strong>boy.get_name() 和 boy.get_sex(‘男’)</strong> <strong>是通过实例来调用方法</strong>。<br>刚才是以 boy = Person(‘rocky’) 的方式创建了一个实例，仿照这个样式还可以建立更多的实例，比如 girl = Person(‘gakki’) 等，也就是说，一个类可以创建多个实例。</p><p>这就是通过类创建实例，并且通过实例来调用属性和方法的过程</p><p>内容引自Rocky0429博客</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python闭包</title>
      <link href="/ArthurDream/2020/07/16/Python%E9%97%AD%E5%8C%85/"/>
      <url>/ArthurDream/2020/07/16/Python%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><p>我们都知道在数学中有闭包的概念，但此处我要说的闭包是计算机编程语言中的概念，它被广泛的使用 于函数式编程。</p><p>关于闭包的概念，官方的定义颇为严格，也很难理解，在《Python语言及其应用》一书中关于闭包的解 释我觉得比较好 — <strong>闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变 量的值</strong>。乍一看，好像还是比较很难懂，下面用一个简单的例子来解释一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span> </span><br><span class="line">...print(a)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun() </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">...b = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b) </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>毋庸置疑，第一段程序是可以运行成功的，a = 1 定义的变量在函数里可以被调用，但是反过来，第二 段程序则出现了报错。<br>在函数 fun() 里可以直接使用外面的 a = 1，但是在函数 fun1() 外面不能使用它里面所定义的 b = 1，如 果我们根据作用域的关系来解释，是没有什么异议的，但是如果在某种特殊情况下，我们必须要在函数 外面使用函数里面的变量，该怎么办呢？<br>先来看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span> </span><br><span class="line">...a = <span class="number">1</span></span><br><span class="line">...<span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span> </span><br><span class="line">... <span class="keyword">return</span> a </span><br><span class="line">...<span class="keyword">return</span> fun1</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fun() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f()) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>在函数 fun() 里面，有 a = 1 和 函数 fun1() ,它们两个都在函数 fun() 的环境里面，但是它们两个是互不干扰的，所以 a 相对于 fun1() 来说是自由变量，并且在函数 fun1() 中应用了这个自由变量 — 这个 <strong>fun1()</strong> 就是我们所定义的<strong>闭包</strong>。<br>闭包实际上就是一个函数，但是这个函数要具有 1.定义在另外一个函数里面(嵌套函数)；2.引用其所在 环境的自由变量。<br>上述例子通过闭包在 fun() 执行完毕时，a = 1依然可以在 f() 中，即 fun1() 函数中存在，并没有被收 回，所以 print(f()) 才得到了结果。<br>当我们在某些时候需要对事务做更高层次的抽象，用闭包会相当舒服。比如我们要写一个二元一次函 数，如果不使用闭包的话相信你可以轻而易举的写出来，下面让我们来用闭包的方式完成这个一元二次 方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a,b,c)</span>:</span> </span><br><span class="line">...<span class="function"><span class="keyword">def</span> <span class="title">para</span><span class="params">(x)</span>:</span></span><br><span class="line">...<span class="keyword">return</span> a*x**<span class="number">2</span> + b*x + c </span><br><span class="line">...<span class="keyword">return</span> para</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f(<span class="number">2</span>)) </span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>上面的函数中，f = fun(1,2,3) 定义了一个一元二次函数的函数对象，x^2 + 2x + 3，如果要计算 x = 2 ， 该一元二次函数的值，只需要计算 f(2) 即可，这种写法更简洁一些。</p><p>内容参考Rocky0429微信公众号</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环 迭代 递归 遍历</title>
      <link href="/ArthurDream/2020/07/15/%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E9%81%8D%E5%8E%86/"/>
      <url>/ArthurDream/2020/07/15/%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-循环（loop）"><a href="#1-循环（loop）" class="headerlink" title="1.循环（loop）"></a>1.循环（loop）</h3><p>循环是指在满足条件的情况下，重复执行同一段代码，比如 while 语句</p><h3 id="2-迭代（Iterate）"><a href="#2-迭代（Iterate）" class="headerlink" title="2.迭代（Iterate）"></a>2.迭代（Iterate）</h3><p>迭代是指按照某种顺序逐个访问对象中的每一项，比如 for 语句</p><h3 id="3-递归（recursion）"><a href="#3-递归（recursion）" class="headerlink" title="3.递归（recursion）"></a>3.递归（recursion）</h3><p>递归是指一个函数不断调用自身的行为，比如斐波那契数列</p><h3 id="4-遍历（traversal）"><a href="#4-遍历（traversal）" class="headerlink" title="4.遍历（traversal）"></a>4.遍历（traversal）</h3><p>遍历是指按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次</p><h3 id="Python中的逐个访问"><a href="#Python中的逐个访问" class="headerlink" title="Python中的逐个访问"></a>Python中的逐个访问</h3><p>在 Python 中，如果想要访问对象中的每个元素，可以像下面这样做，以列表举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'c'</span>,<span class="string">'k'</span>,<span class="string">'y'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">...print(i,end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">r o c k y </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>除了上述方法以外，还可以像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter = iter(my_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"><span class="string">'r'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'k'</span></span><br><span class="line">&gt;&gt;&gt;my_iter.__next__() </span><br><span class="line"><span class="string">'y'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上面的 iter() 是一个内建函数，返回的是一个迭代器对象</p><p>在 Python3 中，所有的迭代器对象都有 next() 方法，迭代器，当然是可迭代的，在上面的例子中， next() 就是要获得下一个对象，但是作为一个 “懒惰” 的程序员来说，上面的那种方法一个个的敲太麻 烦了，所以就有了下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">...print(my_iter.__next__())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上面出现了错误，我们先不管，再来它一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter = iter(my_list) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">...print(my_iter.__next__())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">r </span><br><span class="line">o </span><br><span class="line">c </span><br><span class="line">k </span><br><span class="line">y </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>看了上面演示的例子可以发现，如果我们用 for 循环来写的话，当到了末尾的时候就自动结束了，但是 用了 next() 的话，当完成最后一个的时候它不会自动结束，还会向下继续，但是后面已经没有元素 了，所以就发出了一个 StopIteration 的信息，即停止迭代。<br>在这我们还要再关注一下迭代器对象的另一个特点，看上上个的那个例子就可以知道，对象 my_iter 被 迭代结束后，即每个元素都读取了一遍之后，指针就移到了最后一个元素后面，如果想要再访问的话， 指针并没有自动移动到初始位置，所以会报 StopIteration，如果想要重新开始的话，就需要重新载入 迭代对象。</p><h3 id="文件迭代器"><a href="#文件迭代器" class="headerlink" title="文件迭代器"></a>文件迭代器</h3><p>现在有一个 “test.txt” 的文件，文件内容是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> Rocky </span><br><span class="line">I love Python </span><br><span class="line">a，hhhhhhh</span><br></pre></td></tr></table></figure><p>现在用迭代器来尝试操作这个文件，我们其实在之前两天讲述有关文件的知识的时候已经讲过了，就是 用 readline() 一行一行的读，当然在实际操作中，我们是绝对不会这样做的，因为我们 “懒” 啊，一定要 让它自动进行，比较常用的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'test.txt'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f: </span><br><span class="line">...print(line,end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">My name <span class="keyword">is</span> Rocky</span><br><span class="line">I love Python </span><br><span class="line">a，hhhhhhh &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>上面的过程当然用 next() 也能够读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'My name is Rocky\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'I love Python\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'a，hhhhhhh'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>用 next() 就可以直接读取每行的内容，这就说明文件是天生可迭代的对象，不需要用 iter() 转换。 再者，我们用 for 来实现迭代，本质上就是自动调用 next() ，只不过这个工作被 for 偷偷的做了，所以 for 是活雷锋无疑了。</p><p>文章参考Rocky0429公众号中的部分内容</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命名规范</title>
      <link href="/ArthurDream/2020/07/07/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/ArthurDream/2020/07/07/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、命名规范</p><p>1、 项目名全部小写</p><p>2、 包名全部小写</p><p>3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。</p><p>如：public class MyFirstClass{}</p><p>4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。</p><p>如：int index=0;</p><pre><code>   public void toString(){}</code></pre><p>5、 常量名全部大写</p><p>如：public static final String GAME_COLOR=”RED”;</p><p>6、所有命名规则必须遵循以下规则：</p><p>1)、名称只能由字母、数字、下划线、$符号组成</p><p>2)、不能以数字开头</p><p>3)、名称不能使用JAVA中的关键字。</p><p>4)、坚决不允许出现中文及拼音命名。</p><p>二、注释规范</p><p>1、   类注释</p><p>在每个类前面必须加上类注释，注释模板如下：</p><p>/**</p><ul><li>Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.</li><li>FileName: Test.java</li><li>类的详细说明</li><li></li><li><p>@author 类创建者姓名</p><ul><li>@Date    创建日期</li></ul></li><li><p>@version 1.00</p></li></ul><p>*/</p><p>2、   属性注释</p><p>在每个属性前面必须加上属性注释，注释模板如下：</p><p>/<em>* 提示信息 </em>/</p><p>private String strMsg = null;</p><p>3、   方法注释</p><p>在每个方法前面必须加上方法注释，注释模板如下：</p><p>/**</p><ul><li>类方法的详细使用说明</li><li></li><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@return 返回结果的说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>4、   构造方法注释</p><p>在每个构造方法前面必须加上注释，注释模板如下：</p><p>/**</p><ul><li>构造方法的详细使用说明</li><li></li><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>5、   方法内部注释</p><p>在方法内部使用单行或者多行注释，该注释根据实际情况添加。</p><p>如：//背景颜色</p><pre><code>   Color bgColor = Color.RED</code></pre><p>内容仅供个人学习、记录使用，侵删</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session的空属性判断问题</title>
      <link href="/ArthurDream/2020/07/07/session%E7%9A%84%E7%A9%BA%E5%B1%9E%E6%80%A7%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/"/>
      <url>/ArthurDream/2020/07/07/session%E7%9A%84%E7%A9%BA%E5%B1%9E%E6%80%A7%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    记录一个今天遇到的小问题：（新手编程，若有错误，希望各位及时指正，感激不尽）<br>​    首先，若后端放session时，某些属性为空值（比如下面的resume属性），则到了session里时会变为空字符串，而不是null。</p><p>原因：<br>​    首先什么是session？<br>​    “当访问服务器某个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session”</p><p>​    由此可以看出，当访问页面的时候是已开辟了一段内存的，而null是不指向任何对象，不分配内存空间的;空字符串“”才会分配内存空间。</p><p>​    故此时一切对session里空属性的判断不能对null判断，而应是对空字符串判断，如下面的应为sj.resume!=’ ‘而不能是sj.resume！=null</p><p>​    下面是一段前端代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function sendResume(jid,jobName,uname)&#123;</span><br><span class="line"></span><br><span class="line">        alert(&quot;点击确定开始投递&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;*定义个数组放发送的变量并赋值*&#x2F;</span><br><span class="line">        var sj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        sj.jid&#x3D;jid;</span><br><span class="line">        sj.jobName&#x3D;jobName;</span><br><span class="line">        sj.uname&#x3D;uname;</span><br><span class="line">        sj.sid&#x3D;&#39;$&#123;session.sid &#125;&#39;;</span><br><span class="line">        sj.name&#x3D;&#39;$&#123;session.name &#125;&#39;;</span><br><span class="line">        sj.resume&#x3D;&#39;$&#123;session.resume&#125;&#39;;</span><br><span class="line">        &#x2F;*若后端放session时，某些属性为空值，则到了session里时会变为空字符串，</span><br><span class="line">            故此时一切对其空属性的判断不能对null判断，而是对空字符串判断，如下面的sj.resume!&#x3D;&#39;&#39; *&#x2F;</span><br><span class="line">        if (sj.resume!&#x3D;&#39;&#39;) &#123;</span><br><span class="line"></span><br><span class="line">            alert(&quot;要进入ajax了&quot;);</span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">            &#x2F;*请求类型*&#x2F;</span><br><span class="line">            type:&quot;post&quot;,</span><br><span class="line">            &#x2F;*请求路径*&#x2F;</span><br><span class="line">            url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;application&#x2F;sendResume&quot;,</span><br><span class="line">            &#x2F;*设置类型*&#x2F;</span><br><span class="line">            contentType:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;,</span><br><span class="line">            &#x2F;*向后端传数据，stringify方法将sj转换为json格式*&#x2F;</span><br><span class="line">            data: JSON.stringify(sj),</span><br><span class="line">            &#x2F;*然后在这个弹窗里去显示出来*&#x2F;</span><br><span class="line">            success:function(data) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;*后端return的值默认都装在叫data的变量里*&#x2F;</span><br><span class="line">                if(data&#x3D;&quot;0&quot;)&#123;</span><br><span class="line">                    alert(&quot;投递成功！&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    alert(&quot;投递失败！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                window.location.reload();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            alert(&quot;请先上传简历！&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/ArthurDream/2020/07/06/hello-world/"/>
      <url>/ArthurDream/2020/07/06/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello World！</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
