<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis心得（转载）</title>
      <link href="/ArthurDream/2020/10/22/Redis%E5%BF%83%E5%BE%97%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/ArthurDream/2020/10/22/Redis%E5%BF%83%E5%BE%97%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis心得体会（转载）"><a href="#Redis心得体会（转载）" class="headerlink" title="Redis心得体会（转载）"></a>Redis心得体会（转载）</h1><p>Redis简介：</p><p>​         在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p><p>NoSQL 技术：</p><p>解决了一系列问题，这是一种<strong>基于内存的数据库</strong>，并且提供一定的持久化功能。，因此出现了<strong>Redis</strong>和<strong>MongoDB，\</strong>Redis*<em>和*</em>MongoDB*<strong>*是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以</strong>支持每秒十几万此的读/写操作<strong>，其性能远超数据库，并且还</strong>支持集群、分布式、主从同步等<strong>配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还</strong>支持一定的事务能力**，这保证了高并发的场景下数据的安全和一致性。</p><p><strong>Redis 在 Java Web 主要有两个应用场景：</strong></p><ul><li>存储 <strong>缓存</strong> 用的数据；</li><li>需要高速读/写的场合<strong>使用它快速读/写</strong>；</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在日常对数据库的访问中，读操作的次数远超写操作，比例大概在 <strong>1:9</strong> 到 <strong>3:7</strong>，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会<strong>去磁盘把对应的数据索引取回来</strong>，这是一个相对较慢的过程。</p><p>如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端<strong>直接去读取内存中的数据</strong>，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们<strong>只是使用 Redis 存储一些常用和主要的数据</strong>，比如用户登录的信息等</p><p>一般而言在使用 Redis 进行存储的时候，我们需要从以下几个方面来考虑：</p><ul><li><strong>业务数据常用吗？命中率如何？</strong>如果命中率很低，就没有必要写入缓存；</li><li><strong>该业务数据是读操作多，还是写操作多？</strong>如果写操作多，频繁需要写入数据库，也没有必要使用缓存；</li><li><strong>业务数据大小如何？</strong>如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；</li></ul><p>使用 Redis 作为缓存的读取逻辑如下图所示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis1.png" alt="img"></p><p>从上图我们可以知道以下两点：</p><ol><li>当<strong>第一次读取数据的时候</strong>，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；</li><li>当<strong>第二次以及以后需要读取数据时</strong>，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。</li></ol><p>从上面的分析可以知道，读操作的可能性是远大于写操作的，所以使用 Redis 来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。</p><p>分析了读操作的逻辑，下面我们来看看<strong>写操作的流程</strong>：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis2.png" alt="img"></p><p>从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。</p><blockquote><p>关于使用内存存储数据，我知道谷歌好像就是<strong>把所有互联网的数据都存储在内存条</strong>的，所以才会有如此高质量、高效的搜索，但它毕竟是谷歌…</p></blockquote><h4 id="高速读-写的场合"><a href="#高速读-写的场合" class="headerlink" title="高速读/写的场合"></a>高速读/写的场合</h4><p>在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有<strong>成千上万的请求</strong>到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，<strong>轻则造成用户体验极差用户量流失</strong>，<strong>重则数据库瘫痪，服务宕机</strong>，而这样的场合都是不允许的！</p><p>所以我们需要使用 Redis 来应对这样的高并发需求的场合，我们先来看看<strong>一次请求操作的流程图</strong>：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis3.png" alt="img"></p><p>我们来进一步阐述这个过程：</p><ol><li>当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足<strong>高速响应的需求</strong>；</li><li>但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去<strong>判断该高速读/写的业务是否结束</strong>，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式<strong>一次性写入数据库</strong>，从而完成持久化的工作。</li></ol><p>加压后如图：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://img2018.cnblogs.com/blog/1715978/201907/1715978-20190715153757526-673189666.png" alt="img"></p><p>安装redis服务命令：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://arthurblog.oss-cn-beijing.aliyuncs.com/Redis5.png" alt="img"></p><p>需要注意的是：所有命令需要在window解压的redis根目录执行，免安装的情况下,window 切换目录需要首先切到盘符D：然后cd到盘符的指定路径</p><p>相关配置文件和官方文档都在下载的目录中，比如下面的conf文件可以修改服务的端口号，默认的是6397</p><p><strong>原文链接<a href="https://www.cnblogs.com/zoli/p/11189288.html" target="_blank" rel="noopener">https://www.cnblogs.com/zoli/p/11189288.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用Web组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程和多进程</title>
      <link href="/ArthurDream/2020/09/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/ArthurDream/2020/09/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><p>面试的时候，经常被问到 进程和线程的区别。</p><p>简单的说：<strong>进程就是运行着的程序</strong>。</p><p>我们写的python程序（或者其他应用程序比如画笔、qq等），运行起来，就称之为一个<strong>进程</strong></p><p>在windows下面打开任务管理器，里面显示了当前系统上运行着的进程。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/gh/36257654_36931680-3344f066-1ef6-11e8-9c71-bad64c5624c7.png" alt="白月黑羽Python3教程"></p><p>可以看到，我们系统中有很多的进程运行着，比如qq、搜狗输入法等。</p><p>这些程序还没有运行的时候，它们的程序代码文件存储在磁盘中，就是那些扩展名为 <code>.exe</code> 文件。</p><p>双击它们，这些 <code>.exe</code> 文件就被os加载到内存中，运行起来，成为进程</p><p>而系统中每个进程里面至少包含一个 <strong>线程</strong> 。</p><p>线程是操作系统创建的，每个线程对应一个代码执行的数据结构，保存了代码执行过程中的重要的状态信息。</p><p>没有线程，操作系统没法管理和维护 代码运行的状态信息。</p><p>所以没有创建线程之前，操作系统是不会执行我们的代码的。</p><p>我们前面写的Python程序，里面虽然没有创建线程的代码，但实际上，当Python解释器程序运行起来（成为一个进程），OS就自动的创建一个线程，通常称为<strong>主线程</strong>，在这个主线程里面执行代码指令。</p><p>当解释器执行我们python程序代码的时候。 我们的代码就在这个主线程中解释执行。</p><p>比如：下面这个程序，运行起来后，只有一个线程，就是主线程，在主线程里面，执行代码，顺序下来，一直执行到结束， 主线程就退出了。 同时进程也结束了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fee = input(<span class="string">'请输入午餐费用：'</span>)</span><br><span class="line">members = input(<span class="string">'请输入聚餐人姓名，以英文逗号,分隔：'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将人员放入一个列表</span></span><br><span class="line">memberlist = members.split(<span class="string">','</span>) </span><br><span class="line"><span class="comment"># 得到人数</span></span><br><span class="line">headcount = len(memberlist) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算人均费用</span></span><br><span class="line">avgfee = int (fee) / headcount</span><br><span class="line">print(avgfee)</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.bilibili.com/video/av74106411/?p=75" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>现代计算机上面，CPU是多核的， 每个核都可以执行代码。</p><p>要运行程序里面的代码，操作系统就会分配一个CPU核心去执行该代码。</p><p>有的时候，我们希望，能够让更多的CPU核心同时执行我们的程序里面的一些代码。</p><p>假如，我们程序里面有个名为 compress 的函数，执行压缩文件的任务。</p><p>现在有4个大文件，需要压缩。</p><p>如果是一个CPU核心执行这个函数（单线程的程序），压缩一个文件要10秒钟的话， 那么压缩4个文件，就要40秒。</p><p>如果我们能够让 4个CPU核心 <code>同时</code> 执行压缩函数， 理论上就只要 10秒。</p><hr><p>有的时候， 我们有一批任务要执行，而这些任务的执行时间主要耗费在 <code>非CPU计算</code> 上面。</p><p>比如，我们需要到 前程无忧 网站 抓取 python 开发相关的职位信息。</p><p>我们要抓取几百个网页的内容， 执行这些抓取信息的任务的代码，时间主要耗费在等待网站返回信息上面。 等待信息返回的时候CPU是空闲的。</p><p>如果我们像以前那样 在一个线程里面，用一个循环 依次 获取100个网页的信息，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 网页的职位信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">grabOnePage</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'代码发起请求，抓取网页信息，具体代码省略'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pageIdx <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    url = <span class="string">f'https://search.51job.com/list/020000,000000,0000,00,9,99,python,2,<span class="subst">&#123;pageIdx&#125;</span>.html'</span></span><br><span class="line">    grabOnePage(url)</span><br></pre></td></tr></table></figure><p>就会有很长的时间耗费在 等待服务器返回信息上面。</p><p>如果我们能用100个线程，同时运行 获取网页信息的代码， 理论上，可以100倍的减少执行时间。</p><hr><p>要让多个CPU核心同时去执行任务，我们的程序必须 <code>创建多个线程</code> ，让 CPU 执行 多个线程 对应的代码。</p><h2 id="Python代码中创建新线程"><a href="#Python代码中创建新线程" class="headerlink" title="Python代码中创建新线程"></a>Python代码中创建新线程</h2><p><a href="https://www.bilibili.com/video/av74106411/?p=76" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>那么我们的程序代码怎么产生新线程呢？</p><p>应用程序必须 通过操作系统提供的 <strong>系统调用</strong>，请求操作系统分配一个新的线程。</p><p>python3 将 系统调用创建线程 的功能封装在 标准库 threading 中。</p><p>大家来看下面的一段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'主线程执行代码'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 threading 库中导入Thread类</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">(arg1,arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'子线程 开始'</span>)</span><br><span class="line">    print(<span class="string">f'线程函数参数是：<span class="subst">&#123;arg1&#125;</span>, <span class="subst">&#123;arg2&#125;</span>'</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Thread 类的实例对象， 并且指定新线程的入口函数</span></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行start 方法，就会创建新线程，</span></span><br><span class="line"><span class="comment"># 并且新线程会去执行入口函数里面的代码。</span></span><br><span class="line"><span class="comment"># 这时候 这个进程 有两个线程了。</span></span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程的代码执行 子线程对象的join方法，</span></span><br><span class="line"><span class="comment"># 就会等待子线程结束，才继续执行下面的代码</span></span><br><span class="line">thread.join()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>运行该程序，解释器执行到下面代码时</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>)</span><br><span class="line">                )</span><br></pre></td></tr></table></figure><p>创建了一个Thread实例对象，其中，Thread类的初始化参数 有两个</p><p>target参数 是指定新线程的 <strong>入口函数</strong>， 新线程创建后就会 执行该入口函数里面的代码，</p><p>args 指定了 传给 入口函数threadFunc 的参数。 线程入口函数 参数，必须放在一个元组里面，里面的元素依次作为入口函数的参数。</p><p>注意，上面的代码只是创建了一个Thread实例对象， 但这时，<strong>新的线程还没有创建</strong>。</p><p>要创建线程，必须要调用 Thread 实例对象的 <code>start</code>方法 。也就是执行完下面代码的时候</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>新的线程才创建成功，并开始执行 入口函数threadFunc 里面的代码。</p><p>有的时候， 一个线程需要等待其它的线程结束，比如需要根据其他线程运行结束后的结果进行处理。</p><p>这时可以使用 Thread对象的 <code>join</code> 方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.join()</span><br></pre></td></tr></table></figure><p>如果一个线程A的代码调用了 对应线程B的Thread对象的 <code>join</code> 方法，线程A就会停止继续执行代码，等待线程B结束。 线程B结束后，线程A才继续执行后续的代码。</p><p>所以主线程在执行上面的代码时，就暂停在此处， 一直要等到 新线程执行完毕，退出后，才会继续执行后续的代码。</p><p>关于多线程join的用途，白月黑羽在和一个VIP实战班学员交流中 有 这样的比喻，如下图所示</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200509150215_68.png" alt="image"></p><p>join通常用于 主线程把任务分配给几个子线程，等待子线程完成工作后，需要对他们任务处理结果进行再处理。</p><p>就好像一个领导把任务分给几个员工，等几个员工完成工作后，他需要收集他们的提高报告，进行后续处理。</p><p>这种情况，主线程必须子线程完成才能进行后续操作，所以join就是 等待参数对应的线程完成，才返回。</p><hr><p>不少学员 创建线程对象 的时候，会写成下面这样</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))</span><br></pre></td></tr></table></figure><p>为什么这样写不对？和下面的写法有什么区别？</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                args=(<span class="string">'参数1'</span>, <span class="string">'参数2'</span>))</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/av65489865/?p=9" target="_blank" rel="noopener">点击这里观看白月黑羽和 VIP 学员的视频交流讲解</a></p><h2 id="共享数据的访问控制"><a href="#共享数据的访问控制" class="headerlink" title="共享数据的访问控制"></a>共享数据的访问控制</h2><p><a href="https://www.bilibili.com/video/av74106411/?p=77" target="_blank" rel="noopener">点击这里，边看视频讲解，边学习以下内容</a></p><p>做多线程开发，经常遇到这样的情况：多个线程里面的代码 需要访问 同一个 公共的数据对象。</p><p>这个公共的数据对象可以是任何类型， 比如一个 列表、字典、或者自定义类的对象。</p><p>有的时候，程序 需要 防止线程的代码 同时操作 公共数据对象。 否则，就有可能导致 数据的访问互相冲突影响。</p><p>请看一个例子。</p><p>我们用一个简单的程序模拟一个银行系统，用户可以往自己的帐号上存钱。</p><p>对应代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line">    print(<span class="string">f'子线程 <span class="subst">&#123;theadidx&#125;</span> 结束'</span>)</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>上面的代码中，一起执行</p><p>开始的时候， 该帐号的余额为0，随后我们启动了10个线程， 每个线程都deposit函数，往帐号byhy上存1元钱。</p><p>可以预期，执行完程序后，该帐号的余额应该为 10。</p><p>然而，我们运行程序后，发现结果如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为什么是 1 呢？ 而不是 10 呢？</p><hr><p>如果在我们程序代码中，只有一个线程，如下所示</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    deposit (idx,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>代码都是 <code>串行</code> 执行的。 不存在多线程同时访问 bank对象 的问题，运行结果一切都是正常的。</p><p>现在我们程序代码中，有多个线程，并且在这个几个线程中都会去调用 deposit，就有可能同时操作这个bank对象，就有可能出一个线程覆盖另外一个线程的结果的问题。</p><p>这时，可以使用 threading库里面的锁对象 <strong>Lock</strong> 去保护。</p><p>我们修改多线程代码，如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">bank = &#123;</span><br><span class="line">    <span class="string">'byhy'</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bankLock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，作为新线程执行的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(theadidx,amount)</span>:</span></span><br><span class="line">    <span class="comment"># 操作共享数据前，申请获取锁</span></span><br><span class="line">    bankLock.acquire()</span><br><span class="line">    </span><br><span class="line">    balance =  bank[<span class="string">'byhy'</span>]</span><br><span class="line">    <span class="comment"># 执行一些任务，耗费了0.1秒</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    bank[<span class="string">'byhy'</span>]  = balance + amount</span><br><span class="line">    print(<span class="string">f'子线程 <span class="subst">&#123;theadidx&#125;</span> 结束'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 操作完共享数据后，申请释放锁</span></span><br><span class="line">    bankLock.release()</span><br><span class="line"></span><br><span class="line">theadlist = []</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target = deposit,</span><br><span class="line">                    args = (idx,<span class="number">1</span>)</span><br><span class="line">                    )</span><br><span class="line">    thread.start()</span><br><span class="line">    <span class="comment"># 把线程对象都存储到 threadlist中</span></span><br><span class="line">    theadlist.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> theadlist:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br><span class="line">print(<span class="string">f'最后我们的账号余额为 <span class="subst">&#123;bank[<span class="string">"byhy"</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>执行一下，结果如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子线程 <span class="number">0</span> 结束</span><br><span class="line">子线程 <span class="number">1</span> 结束</span><br><span class="line">子线程 <span class="number">2</span> 结束</span><br><span class="line">子线程 <span class="number">3</span> 结束</span><br><span class="line">子线程 <span class="number">4</span> 结束</span><br><span class="line">子线程 <span class="number">5</span> 结束</span><br><span class="line">子线程 <span class="number">6</span> 结束</span><br><span class="line">子线程 <span class="number">7</span> 结束</span><br><span class="line">子线程 <span class="number">8</span> 结束</span><br><span class="line">子线程 <span class="number">9</span> 结束</span><br><span class="line">主线程结束</span><br><span class="line">最后我们的账号余额为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>正确了。</p><p>Lock 对象的acquire方法 是申请锁。</p><p>每个线程在 操作共享数据对象之前，都应该 申请获取操作权，也就是 调用该 共享数据对象对应的锁对象的acquire方法。</p><p>如果线程A 执行如下代码，调用acquire方法的时候，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bankLock.acquire()</span><br></pre></td></tr></table></figure><p>别的线程B 已经申请到了这个锁， 并且还没有释放，那么 线程A的代码就在此处 等待 线程B 释放锁，不去执行后面的代码。</p><p>直到线程B 执行了锁的 release 方法释放了这个锁， 线程A 才可以获取这个锁，就可以执行下面的代码了。</p><p>如果这时线程B 又执行 这个锁的acquire方法， 就需要等待线程A 执行该锁对象的release方法释放锁， 否则也会等待，不去执行后面的代码。</p><p>具体参考视频里面的讲解。</p><h2 id="daemon线程"><a href="#daemon线程" class="headerlink" title="daemon线程"></a>daemon线程</h2><p>大家执行下面的代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line">thread = Thread(target=threadFunc)</span><br><span class="line">thread.start()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>可以发现，主线程先结束，要过个2秒钟，等子线程运行完，整个程序才会结束退出。</p><p>因为：</p><p>Python程序中当所有的 <code>非daemon线程</code> 结束了，整个程序才会结束</p><p>主线程是非daemon线程，启动的子线程缺省也是 非daemon线程 线程。</p><p>所以，要等到 主线程和子线程 都结束，程序才会结束。</p><p>我们可以在创建线程的时候，设置daemon参数值为True，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'子线程 结束'</span>)</span><br><span class="line"></span><br><span class="line">thread = Thread(target=threadFunc,</span><br><span class="line">                daemon=<span class="literal">True</span> <span class="comment"># 设置新线程为daemon线程</span></span><br><span class="line">                )</span><br><span class="line">thread.start()</span><br><span class="line">print(<span class="string">'主线程结束'</span>)</span><br></pre></td></tr></table></figure><p>再次运行，可以发现，只要主线程结束了，整个程序就结束了。因为只有主线程是非daemon线程。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Python 官方解释器 的每个线程要获得执行权限，必须获取一个叫 GIL （全局解释器锁） 的东西。</p><p>这就导致了 Python 的多个线程 其实 并不能同时使用 多个CPU核心。</p><p>所以如果是计算密集型的任务，不能采用多线程的方式。</p><p>大家可以运行一下如下代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="comment"># 启动10个线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Thread(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>运行后，打开任务管理器，可以发现 即使是启动了10个线程，依然只能占用一个CPU核心的运算能力。</p><p>如下图所示，我的电脑有4个核心，这个Python进程占用了1个核心的运行能力，所以下图显示25，表示 25% ，也就是 1/4的CPU占用率</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200902191303_10.png" alt="image"></p><p>如果需要利用电脑多个CPU核心的运算能力，可以使用Python的多进程库，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="number">53</span>*<span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Process(target=f)</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><p>运行后，打开任务管理器，可以发现 有3个Python进程，其中主进程CPU占用率为0，两个子进程CPU各占满了一个核心的运算能力。</p><p>如下图所示</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://cdn1.python3.vip/imgs/api/tut_20200902191641_40.png" alt="image"></p><p>仔细看上面的代码，可以发现和多线程的使用方式非常类似。</p><p>还有一个问题，主进程如何获取 子进程的 运算结果呢？</p><p>可以使用多进程库 里面的 Manage 对象，如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Manager</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(taskno,return_dict)</span>:</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 存放计算结果到共享对象中</span></span><br><span class="line">    return_dict[taskno] = taskno</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line">    <span class="comment"># 创建 类似字典的 跨进程 共享对象</span></span><br><span class="line">    return_dict = manager.dict()</span><br><span class="line">    plist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=f, args=(i,return_dict))</span><br><span class="line">        p.start()</span><br><span class="line">        plist.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> plist:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'get result...'</span>)</span><br><span class="line">    <span class="comment"># 从共享对象中取出其他进程的计算结果</span></span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> return_dict.items():</span><br><span class="line">        <span class="keyword">print</span> (k,v)</span><br></pre></td></tr></table></figure><p>（个人收藏用，转自<a href="http://www.python3.vip，强烈安利这个网站）" target="_blank" rel="noopener">http://www.python3.vip，强烈安利这个网站）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux复习</title>
      <link href="/ArthurDream/2020/09/26/Linux%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/09/26/Linux%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux系统目录结构说明"><a href="#Linux系统目录结构说明" class="headerlink" title="Linux系统目录结构说明"></a><strong>Linux系统目录结构说明</strong></h1><p>登录系统后，在当前命令窗口下输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure><p>会看到如下图所示:</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/06/4_20.png" alt="img"></p><p>树状目录结构：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="img"></p><p>以下是对这些目录的解释：</p><ul><li><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p></li><li><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p></li><li><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p></li></ul><p><strong>指令集合：</strong></p><ul><li><p><strong>/bin：</strong>存放着最常用的程序和指令</p></li><li><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>外部文件管理：</strong></p><ul><li><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p></li><li><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p></li><li><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li></ul><p><strong>临时文件：</strong></p><ul><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li><li><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p></li></ul><p><strong>账户：</strong></p><ul><li><p><strong>/root</strong>：系统管理员的用户主目录。</p></li><li><p><strong>/home</strong>：用户的主目录，以用户的账号命名的。</p></li><li><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p></li><li><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p></li><li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p></li></ul><p><strong>运行过程中要用：</strong></p><ul><li><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p></li><li><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p></li></ul><p><strong>扩展用的：</strong></p><ul><li><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p></li><li><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p></li></ul><h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组</p><p>第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如下图）。</p><p><img src= "/ArthurDream/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中，第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><strong>绝对路径：</strong><br>路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li><li><strong>相对路径：</strong><br>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法啦！</li></ul><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录及文件名</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~]# ls [--color&#x3D;&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~]# ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将家目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#使用 mkdir 命令创建 runoob 目录</span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"></span><br><span class="line">#使用绝对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd &#x2F;root&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line">#使用相对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd .&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 &#x2F;root 这个目录</span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"># 表示去到目前的上一级目录，亦即是 &#x2F;root 的上一级目录的意思；</span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# pwd [-P]</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# pwd</span><br><span class="line">&#x2F;root   &lt;&#x3D;&#x3D; 显示出目录啦～</span><br></pre></td></tr></table></figure><p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;var&#x2F;mail   &lt;&#x3D;&#x3D;注意，&#x2F;var&#x2F;mail是一个连结档</span><br><span class="line">[root@www mail]# pwd</span><br><span class="line">&#x2F;var&#x2F;mail         &lt;&#x3D;&#x3D;列出目前的工作目录</span><br><span class="line">[root@www mail]# pwd -P</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;mail   &lt;&#x3D;&#x3D;怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@www mail]# ls -ld &#x2F;var&#x2F;mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 Sep  4 17:54 &#x2F;var&#x2F;mail -&gt; spool&#x2F;mail</span><br><span class="line"># 看到这里应该知道为啥了吧？因为 &#x2F;var&#x2F;mail 是连结档，连结到 &#x2F;var&#x2F;spool&#x2F;mail </span><br><span class="line"># 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</span><br></pre></td></tr></table></figure><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到/tmp底下尝试创建数个新目录看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# mkdir test    &lt;&#x3D;&#x3D;创建一名为 test 的新目录</span><br><span class="line">[root@www tmp]# mkdir test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">mkdir: cannot create directory &#96;test1&#x2F;test2&#x2F;test3&#x2F;test4&#39;: </span><br><span class="line">No such file or directory       &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！</span><br><span class="line">[root@www tmp]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br></pre></td></tr></table></figure><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# mkdir -m 711 test2</span><br><span class="line">[root@www tmp]# ls -l</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li></ul><p>删除 runoob 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# rmdir runoob&#x2F;</span><br></pre></td></tr></table></figure><p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# ls -l   &lt;&#x3D;&#x3D;看看有多少目录存在？</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br><span class="line">[root@www tmp]# rmdir test   &lt;&#x3D;&#x3D;可直接删除掉，没问题</span><br><span class="line">[root@www tmp]# rmdir test1  &lt;&#x3D;&#x3D;因为尚有内容，所以无法删除！</span><br><span class="line">rmdir: &#96;test1&#39;: Directory not empty</span><br><span class="line">[root@www tmp]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">[root@www tmp]# ls -l        &lt;&#x3D;&#x3D;您看看，底下的输出中test与test1不见了！</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">[root@www ~]# cp -i ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">cp: overwrite &#96;&#x2F;tmp&#x2F;bashrc&#39;? n  &lt;&#x3D;&#x3D;n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# rm -i bashrc</span><br><span class="line">rm: remove regular file &#96;bashrc&#39;? y</span><br></pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# cp ~&#x2F;.bashrc bashrc</span><br><span class="line">[root@www tmp]# mkdir mvtest</span><br><span class="line">[root@www tmp]# mv bashrc mvtest\</span><br></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www tmp]# mv mvtest mvtest2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSMA/CA与CSMA/CD的异同</title>
      <link href="/ArthurDream/2020/09/26/CSMA-CA%E4%B8%8ECSMA-CD%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/ArthurDream/2020/09/26/CSMA-CA%E4%B8%8ECSMA-CD%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、CSMA-CD-概述"><a href="#一、CSMA-CD-概述" class="headerlink" title="一、CSMA/CD 概述"></a>一、CSMA/CD 概述</h2><p>​    CSMA/CD协议（Carrier Sense Multiple Access with Collision Detection）即<strong>载波帧听，多路访问/冲突检测</strong></p><p>​    <strong>载波侦听</strong>：多个计算机在<strong>发送数据帧前，首先帧听是否空闲</strong>，如果空闲，则发送数据帧；否则等待，继续帧听直到信道空闲。</p><p>   <strong>多路访问</strong>：许多计算机以<strong>多点接入</strong>方式连接在一根总线上，都有访问总线的权利。</p><h2 id="二、CSMA-CD控制方式原理"><a href="#二、CSMA-CD控制方式原理" class="headerlink" title="二、CSMA/CD控制方式原理"></a>二、CSMA/CD控制方式原理</h2><p>​    各工作站在发送数据前，需<u>先侦听信道是否空闲</u>。若空闲，则立即发送数据；若信道忙碌，则等待一段时间至信道中的信息传输结束后再发送数据；若在上一段信息发送结束后，同时有两个或两个以上的节点都提出发送请求，则判定为冲突；<strong>若侦听到冲突，则所有节点立即停止发送数据，等待一段随机时间，再重新尝试发送</strong>。如下图所示：</p><p><img src= "/ArthurDream/img/loading.gif" data-src="http://www.wonggang.com/wp-content/uploads/2018/05/152346131339817c52c7c5e.gif" alt="CSMA/CD"></p><p>CSMA/CD控制方式作用: 提供寻址和媒体存取的控制方式，使得不同设备或网络上的节点可以在多点的网络上通信而不相互冲突。</p><h2 id="三、CSMA-CD-特点"><a href="#三、CSMA-CD-特点" class="headerlink" title="三、CSMA/CD 特点"></a>三、CSMA/CD 特点</h2><p>   1、 使用 CSMA/CD 协议的以太网不能进行全双工通信,而只能进行双向交替通信（半双工通信）。<br>   2、 计算机发送数据帧之后的一小段时间内，存在着遭遇冲突的可能性。<br>   3、 冲突不确定性使整个以太网平均数据率远小于以太网最高数据率。</p><p>​                                              <strong>部分2</strong></p><hr><h2 id="一、CSMA-CA"><a href="#一、CSMA-CA" class="headerlink" title="一、CSMA/CA"></a>一、CSMA/CA</h2><p>   CSMA/CA （Carrier Sense Multiple Access with Collision Avoidance） 即<strong>载波侦听多路访问／冲突避免</strong>。</p><p>采用该协议要求设备要主动<strong>避免冲突</strong>而非被动侦测的方式来解决冲突问题。避免冲突的方法主要有两个：<br>    1、监听到信道空闲时，并不是立即发送，而是<strong>等待一段时间</strong>再发送数据。<br>    2、先发送一个很小的信道侦测帧RTS，如果收到最近的接入点返回的CTS，就认为信道是空闲的，然后再发送数据</p><p>协议的主要流程如下：<br>   1、 首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。<br>   2、 接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。<br>   3、 发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，再发送数据。</p><p>二、CSMA/CD 与CSMA/CA  两者区别</p><p>   1、 CSMA/CD主要着眼点在冲突的侦测，当侦测到冲突时，进行相应的处理，要求设备能一边侦测一边发送数据。<br>    2、CSMA/CA主要着眼点在冲突的避免，协议里也看到经常是等待一段时间再做动作，通过退避尽量去避免冲突，还有就是先发送一些特别小的信道侦测帧来测试信道是否有冲突。</p><p>三、应用</p><p>​     CSMA/CD主要适用<strong>以太网</strong>。<br>​     CSMA/CA主要适用<strong>无线局域网</strong>。</p><p>​                                              <strong>部分2</strong></p><p>参考：</p><p>1、<a href="https://blog.csdn.net/lixuande19871015/article/details/78783740" target="_blank" rel="noopener">https://blog.csdn.net/lixuande19871015/article/details/78783740</a></p><p>2、<a href="http://www.wonggang.com/8126.html" target="_blank" rel="noopener">http://www.wonggang.com/8126.html</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX 知识复习(转)</title>
      <link href="/ArthurDream/2020/08/03/Ajax%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/08/03/Ajax%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="AJAX-简介"><a href="#AJAX-简介" class="headerlink" title="AJAX 简介"></a>AJAX 简介</h2><hr><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><hr><h2 id="什么是-AJAX-？"><a href="#什么是-AJAX-？" class="headerlink" title="什么是 AJAX ？"></a>什么是 AJAX ？</h2><p>AJAX = 异步 JavaScript 和 XML。</p><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p><p><a href="https://arthurblog.oss-cn-beijing.aliyuncs.com/Ajax1.png" target="_blank" rel="noopener">https://arthurblog.oss-cn-beijing.aliyuncs.com/Ajax1.png</a></p><h2 id="AJAX是基于现有的Internet标准"><a href="#AJAX是基于现有的Internet标准" class="headerlink" title="AJAX是基于现有的Internet标准"></a>AJAX是基于现有的Internet标准</h2><p>AJAX是基于现有的Internet标准，并且联合使用它们：</p><ul><li>XMLHttpRequest 对象 (异步的与服务器交换数据)</li><li>JavaScript/DOM (信息显示/交互)</li><li>CSS (给数据定义样式)</li><li>XML (作为转换数据的格式)</li></ul><h2 id="AJAX-XMLHttpRequest对象"><a href="#AJAX-XMLHttpRequest对象" class="headerlink" title="AJAX - XMLHttpRequest对象"></a>AJAX - XMLHttpRequest对象</h2><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p><p>创建 XMLHttpRequest 对象的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=new XMLHttpRequest();</span><br></pre></td></tr></table></figure><h2 id="AJAX-向服务器发送请求"><a href="#AJAX-向服务器发送请求" class="headerlink" title="AJAX - 向服务器发送请求"></a>AJAX - 向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open("GET","ajax_info.txt",true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">open(<em>method</em>,<em>url</em>,<em>async</em>)</td><td align="left">规定请求的类型、URL 以及是否异步处理请求。<strong><em>method</em></strong>：请求的类型，GET 或 POST；<strong><em>url</em></strong>：文件在服务器上的位置；<strong><em>async</em></strong>：true（异步）或 false（同步）</td></tr><tr><td align="left">send(<em>string</em>)</td><td align="left">将请求发送到服务器。<strong><em>string</em></strong>：仅用于 POST 请求</td></tr></tbody></table><h2 id="用GET-还是-POST？"><a href="#用GET-还是-POST？" class="headerlink" title="用GET 还是 POST？"></a>用GET 还是 POST？</h2><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h2 id="AJAX-服务器响应"><a href="#AJAX-服务器响应" class="headerlink" title="AJAX - 服务器响应"></a>AJAX - 服务器响应</h2><h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">responseText</td><td align="left">获得字符串形式的响应数据。</td></tr><tr><td align="left">responseXML</td><td align="left">获得 XML 形式的响应数据。</td></tr></tbody></table><h2 id="responseText-属性"><a href="#responseText-属性" class="headerlink" title="responseText 属性"></a>responseText 属性</h2><p>如果来自服务器的响应并非 XML，使用 responseText 属性。</p><p>responseText 属性返回字符串形式的响应，因此可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById("myDiv").innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure><h2 id="responseXML-属性"><a href="#responseXML-属性" class="headerlink" title="responseXML 属性"></a>responseXML 属性</h2><p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，使用 responseXML 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlDoc&#x3D;xmlhttp.responseXML;</span><br><span class="line">txt&#x3D;&quot;&quot;;</span><br><span class="line">x&#x3D;xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);</span><br><span class="line">for (i&#x3D;0;i&lt;x.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    txt&#x3D;txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;txt;</span><br></pre></td></tr></table></figure><p>（节选自菜鸟教程）</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON 知识复习</title>
      <link href="/ArthurDream/2020/07/30/JSON%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/ArthurDream/2020/07/30/JSON%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h2><p>JSON 是用于存储和传输数据的格式。</p><p>JSON 通常用于服务端向网页传递数据 。</p><h2 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON?"></a>什么是 JSON?</h2><ul><li>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</li><li>JSON 是一种轻量级的数据交换格式。</li><li>JSON是独立的语言 *****</li><li>JSON 易于理解。</li></ul><ul><li>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。 文本可以被任何编程语言读取及作为数据格式传递。</li></ul><h2 id="JSON-格式化后为-JavaScript-对象"><a href="#JSON-格式化后为-JavaScript-对象" class="headerlink" title="JSON 格式化后为 JavaScript 对象"></a>JSON 格式化后为 JavaScript 对象</h2><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的。</p><p>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象。</p><h2 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h2><ul><li>数据为 键/值 对。</li><li>数据由逗号分隔。</li><li>大括号保存对象</li><li>方括号保存数组</li></ul><h2 id="JSON-数据-一个名称对应一个值"><a href="#JSON-数据-一个名称对应一个值" class="headerlink" title="JSON 数据 - 一个名称对应一个值"></a>JSON 数据 - 一个名称对应一个值</h2><p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p><p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;:&quot;Arthur&quot;</span><br></pre></td></tr></table></figure><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><p>JSON 对象保存在大括号内。</p><p>就像在 JavaScript 中, 对象可以保存多个 键/值 对：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"name":"Baidu", "url":"www.baidu.com"&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h2><p>JSON 数组保存在中括号内。</p><p>就像在 JavaScript 中, 数组可以包含对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"sites":[    </span><br><span class="line">&#123;"name":"Baidu", "url":"www.baidu.com"&#125;,     </span><br><span class="line">&#123;"name":"Google", "url":"www.google.com"&#125;,    </span><br><span class="line">&#123;"name":"Taobao", "url":"www.taobao.com"&#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在以上实例中，对象 “sites” 是一个数组，包含了三个对象。</p><p>每个对象为站点的信息（网站名和网站地址）。</p><h2 id="JSON-字符串转换为-JavaScript-对象"><a href="#JSON-字符串转换为-JavaScript-对象" class="headerlink" title="JSON 字符串转换为 JavaScript 对象"></a>JSON 字符串转换为 JavaScript 对象</h2><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据。</p><p>简单起见，我们网页中直接设置 JSON 字符串 </p><p>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = '&#123; "sites" : [' +</span><br><span class="line">'&#123; "name":"Baidu" , "url":"www.baidu.com" &#125;,' +</span><br><span class="line">'&#123; "name":"Google" , "url":"www.google.com" &#125;,' +</span><br><span class="line">'&#123; "name":"Taobao" , "url":"www.taobao.com" &#125; ]&#125;';</span><br></pre></td></tr></table></figure><p><strong>然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = JSON.parse(text);</span><br></pre></td></tr></table></figure><p>最后，在你的页面中使用新的 JavaScript 对象：</p><p><strong>实例代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSON实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>为 JSON 字符串创建对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> text = <span class="string">'&#123; "sites" : ['</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Baidu" , "url":"www.baidu.com" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Google" , "url":"www.google.com" &#125;,'</span> +</span></span><br><span class="line"><span class="actionscript"><span class="string">'&#123; "name":"Taobao" , "url":"www.taobao.com" &#125; ]&#125;'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">obj = <span class="built_in">JSON</span>.parse(text);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = obj.sites[<span class="number">1</span>].name + <span class="string">" "</span> + obj.sites[<span class="number">1</span>].url;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:%5CUsers%5C%E6%AE%B5%E6%A2%A6%E5%AE%87%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802164743836.png" alt="image-20200802164743836"></p><h2 id="JavaScript-对象转换为JSON-字符串"><a href="#JavaScript-对象转换为JSON-字符串" class="headerlink" title="JavaScript 对象转换为JSON 字符串"></a>JavaScript 对象转换为JSON 字符串</h2><p>JSON 通常用于与服务端交换数据。</p><p>在向服务器发送数据时一般是字符串。</p><p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p><p><strong>语法:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer[, space]])</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><p>value:</p><p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p></li><li><p>replacer:</p><p>可选。用于转换结果的函数或数组。</p><p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p><p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p></li><li><p>space:</p><p>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p></li></ul><h2 id="JavaScript-对象转换"><a href="#JavaScript-对象转换" class="headerlink" title="JavaScript 对象转换"></a>JavaScript 对象转换</h2><p>例如我们向服务器发送以下数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; "name":"baidu", "alexa":10000, "site":"www.baidu.com"&#125;;</span><br></pre></td></tr></table></figure><p>我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myJSON = JSON.stringify(obj);</span><br></pre></td></tr></table></figure><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><p><strong>实例代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>实例代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 对象转换为 JSON 字符串<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> obj = &#123; <span class="string">"name"</span>:<span class="string">"baidu"</span>, <span class="string">"alexa"</span>:<span class="number">10000</span>, <span class="string">"site"</span>:<span class="string">"www.baidu.com"</span>&#125;;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(obj);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:%5CUsers%5C%E6%AE%B5%E6%A2%A6%E5%AE%87%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802165250473.png" alt="image-20200802165250473"></p><h2 id="JavaScript-数组转换"><a href="#JavaScript-数组转换" class="headerlink" title="JavaScript 数组转换"></a>JavaScript 数组转换</h2><p>我们也可以将 JavaScript 数组转换为 JSON 字符串：</p><p><strong>实例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ "Google", "Runoob", "Taobao", "Facebook" ];</span><br><span class="line">var myJSON = JSON.stringify(arr);</span><br></pre></td></tr></table></figure><p>myJSON 为字符串。</p><p>我们可以将 myJSON 发送到服务器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>实例代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>将 JavaScript 数组转换为 JSON 对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> arr = [ <span class="string">"Google"</span>, <span class="string">"Baidu"</span>, <span class="string">"Taobao"</span>, <span class="string">"Facebook"</span> ];</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(arr);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = myJSON;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src= "/ArthurDream/img/loading.gif" data-src="C:%5CUsers%5C%E6%AE%B5%E6%A2%A6%E5%AE%87%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200802165434899.png" alt="image-20200802165434899"></p><p>（内容及部分代码引自菜鸟教程，非常好的自学网站，强烈推荐！）</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自信鸡汤</title>
      <link href="/ArthurDream/2020/07/18/%E8%87%AA%E4%BF%A1%E9%B8%A1%E6%B1%A4/"/>
      <url>/ArthurDream/2020/07/18/%E8%87%AA%E4%BF%A1%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何变得自信起来？"><a href="#如何变得自信起来？" class="headerlink" title="如何变得自信起来？"></a>如何变得自信起来？</h2><p>（摘自知乎 心理指导）</p><p>自信，就是对自己能够达到某种目标的乐观、充分估计。美国作家爱默生说：“自信是成功的第一秘诀。”可以说，拥有自信就拥有无限机会。那么如何增强自信呢？</p><p>增强自信的第一个方法：<strong>关注自己的优点</strong>。在纸上列下十个优点，不论是哪方面（细心、眼睛好看等等，多多益善），在从事各种活动时，想想这些优点，并告诉自己有什么优点。这样有助你提升从事这些活动的自信，这叫做“自信的蔓延效应”。这一效应对提升自信效果很好。</p><p>增强自信的第二个方法：<strong>与自信的人多接触</strong>。“近朱者赤，近墨者黑”这一点对增强自信同样有效。</p><p>增强自信的第三个方法：<strong>自我心理暗示</strong>，不断对自己进行正面心理强化，避免对自己进行负面强化。一旦自己有所进步（不论多小）就对自己说：“我能行！”、“我很棒！”、“我能做得更好！”等等，这将不断提升自己的信心。</p><p>增强自信的第四个方法：<strong>树立自信的外部形象</strong>。首先，保持整洁、得体的仪表，有利于增强一个人的自信；其次，举止自信，如行路目视前方等，刚开始可能不习惯，但过一段时间后就会有发自内心的自信；另外，注意锻炼、保持健美的体形对增强自信也很有帮助。</p><p>增强自信的第五个方法：<strong>不可谦虚过度</strong>。谦虚是必要的，但不可过度，过分贬低自己对自信心的培养是极为不利的。</p><p>增强自信的第六个方法：<strong>学会微笑</strong>。微笑会增加幸福感，进而增强自信。</p><p>增强自信的第七个方法：<strong>扬长避短</strong>。在学习、生活、工作中，抓住机会展现自己的优势、特长，同时注意弥补自己的不足，不断进步，肯定能增强自信。</p><p>增强自信的第八个方法：<strong>阅读名人传记</strong>，因为很多知名人士成名前的自身资质、外部环境并不好，如果多看一些这方面的材料有助于提升自信心。</p><p>增强自信的第九个方法：<strong>做好充分准备</strong>。从事某项活动前如果能做好充分准备，那么，在从事这项活动时，必然较为自信，而且这利于顺利完成活动并增强整体自信心。</p><p>增强自信的第十个方法：<strong>给自己定恰当的目标</strong>，并且在目标达成后，定更高的目标。目标不能太高，否则不易达到，如果达不到，对自信心会有所破坏。</p><p>增强自信的第十一个方法：<strong>冒一次险</strong>。当你做了以前不敢做的事以后，你会发现：原来作这事并没有什么了不起！这对提升自信心很有帮助。</p><p>增强自信的第十二个方法：<strong>排除压力</strong>。过重的压力会使自己意志消沉，对自身产生怀疑，从而破坏自信心，学会排除压力对保持原有自信帮助很大。</p><p>增强自信的第十三个方法：<strong>做自己喜欢做的事</strong>。对自己喜欢做的事，因为比较投入，容易取得成功，继而产生成就感，这非常有利于自信心的提高。</p><p>增强自信的第十四个方法：<strong>保持健康</strong>。注意全面的营养、保证身体锻炼、保持快乐的心境，良好的生理、心理状况会使自己产生幸福感，进而产生自信心。</p><p>增强自信的第十五个方法：<strong>尽量依靠自己</strong>。有事尽量依靠自己解决，能不断激发自身的潜力，并且通过一次次的成功，不断提升自信水平。</p><h2 id="真正的自信来源于对自己作为一个人的信心。"><a href="#真正的自信来源于对自己作为一个人的信心。" class="headerlink" title="真正的自信来源于对自己作为一个人的信心。"></a>真正的自信来源于对自己作为一个人的信心。</h2><p><strong>无论成功或是失败，你都能够坦然面对，既不失望、愤怒，也不自责、绝望</strong>。你既不会因成功而忘乎所以，也不会因挫折而感到沮丧和抑郁。你或许会有强烈的愿望，希望自己做得好，表现出色，并为之付出巨大的努力，但在内心里，你能够接受真实的你。自信的真正来源在于自我接纳，无论好坏你都要接纳你自己，真正的友谊与接纳，表现为困境中的自我扶持。</p><p>学会享受成功，告诉自己：“这很棒，我要享受自己的成功。”即使是小的成功，也要学会表扬自己，你越是体验到成功的快乐，你就越会努力追求成功。如果你的努力仅出于恐惧。事情会变得令人厌烦，你要学会用奖励来激励自己，而不是用恐惧来惩罚自己。当你追求成功而不是避免失败时，你启用了大脑完全不同的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程几个术语的理解</title>
      <link href="/ArthurDream/2020/07/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/ArthurDream/2020/07/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-问题空间"><a href="#1-问题空间" class="headerlink" title="1.问题空间"></a>1.问题空间</h3><p>知道什么是 “<strong>问题空间</strong>” 是一个搬砖的必备基础，我们下面来看一下《维基百科》中关于它的定义： 问题空间是问题解决者对一个问题所达到的全部认识状态，它是由问题解决者利用问题所包含的信息和 已储存的信息主动构成的。<br>一个问题一般由三个方面来定义：<strong>初始状态</strong>（开始时的不完全的信息），<strong>目标状态</strong>（你希望获得的信息 或状态），<strong>操作</strong>（从初始状态到目标状态所采取的步骤）。这三个部分加在一起定义了问题空间。</p><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h3><p>这里的 “对象” 不是你的 “对象”，英文单词是 Object，至于为什么翻译成对象我们不去追究，我们需要 知道的是” <strong>Python 中的一切都是对象</strong>“，不管你是字符串，函数还是类，都是对象。 那你可能问了，Python 都是对象有什么用么？简直是太有用了，这说明 Python 是面向对象编程的！ 大佬们对于对象的定义相当高深：一个对象要有自己的状态，行为和唯一的标识；所有相同类型的对象 所具有的结构和行为在它们共同的类中被定义。大佬们的话确实有水平，但是这个定义对于初学者来说 可能不太好理解。<br>其实简言之，对象应该具有属性（就是大佬们说的状态），方法（就是大佬们说的行为）和标识，但是 标识是自动就完成的，所以我们一般不用管它，所以<strong>一个对象主要就是有属性和方法，属性是说这个东 西是什么，方法是说这个东西能做什么。</strong></p><h3 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3.面向对象"></a>3.面向对象</h3><p>面向对象(OOP)，是现在编程的主流。<strong>面向对象编程可以看作是一种在程序中包含各种独立且又互相调 用的对象的思想</strong>，这个和传统正好相反，传统的思想主张将程序直接看作是一系列对计算机下达的指 令，而面向对象编程中的每一个对象都应该能够接受数据，处理数据并且能将数据传达给其它对象，因 此它们每一个都可以看作是一个小型的机器，即对象。<br>目前来说面向对象编程推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。当我们提到 面向对象的时候，它不仅仅是指一种程序设计方法，更多意义上是一种程序开发方式。</p><h3 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h3><p>在目前所流行的高级编程语言中，“类” 是必须要有的，我们先来看《维基百科》中的定义：<br>在面向对象编程中，<strong>类 (class) 是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所 创建的对象共同的属性和方法。</strong><br>对于类更严格点的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这 些对象就被成为该类的实例。类有接口和结构，接口描述了如何通过方法与类及其实例互相操作，而结 构描述了一个实例中数据如何划分为多个属性。<br>支持类的编程语言在支持与类相关的各种特性方面都多多少少有一些微妙的差异。大多数都支持不同形 式的类继承。类的出现，为面向对象编程的三个最重要的特性（封装，继承，多态）提供了实现的手 段。<br>看到这里，你或许有这么一个认识，要面向对象编程就要用到类，虽然不是很严格，但是我们可以这么 说，当然了，反过来的话是不可以的。</p><p><strong>类是对某一群具有同样属性和方法的对象的抽象</strong>，比如长翅膀会飞的的生物，我们把它们统一称为 “鸟”。</p><h3 id="创建一个-“类”"><a href="#创建一个-“类”" class="headerlink" title="创建一个 “类”"></a>创建一个 “类”</h3><p>如何创建一个 “类”，为了更普遍性的说明，我来写一个具有通常类的结构的类，请看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    具有通常类的结构的 Person 类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sex</span><span class="params">(self,sex)</span>:</span></span><br><span class="line">        per_sex = &#123;&#125;</span><br><span class="line">        per_sex[self.name] = sex</span><br><span class="line">        <span class="keyword">return</span> per_sex</span><br></pre></td></tr></table></figure><p>上面的 Person 类是一个很常见的类，下面我来对它就行逐一解释：<br>在 Python3 中所有的类都是 object 的子类，正是因为这个原因，所以不用像 Python2 中那样要把对 object 的继承写出来。class Person：这是在声明创建一个名字是 “Person” 的类，关键词是 class，就和函数的 def 一样。类 的名字按照惯例一般用大写字母开头，如果名字是两个单词，那么两个单词的首字母都要大写，比如 HotDog，当然了如果你不想这样也是可以的，但是我希望你记住 “你的代码是给别人看的”，不要给别 人和自己以后读代码的时候带来麻烦。最后当所有的一切都结束的时候，别忘了在最后带上冒号。<br>接下来就是类里面的代码块，上面例子中类里的代码块看起来很熟悉，都是 def 这个关键词开头的函 数。你是对的，它们就是函数，但是你仔细看一下就会发现，这些函数跟我们在前面学过的函数略微不 同，它们的参数都有 “self”（<strong>要注意 self 是默认的第一个参数</strong>）。这个正是类中函数的特色，是为了跟 我们以前学过的函数区别开来，所以一般在类里的函数我们不叫它们函数，而叫它们 “方法”。所以<strong>当你 听到有人说 “方法” 的时候，不用奇怪，它和函数在本质上是一样的</strong>。</p><p>下面对类里的几个函数做一个简要的介绍。<br>def <strong>init</strong>(self,name)：这是一个特殊的方法，以<strong>双下划线</strong>开头和结尾，这样的方法其实在类里面还有很 多，统一叫它们 “特殊方法”。对于 init() 还有一个别的名字，叫 “构造函数”，也有叫它是 “初始化方法” 的，个人认为第二个更好一点，因为单从字面上来看，它对应的含义应该是初始化。所谓的初始化，就 是让类有一个基本的样子，而不是里面什么也没有，很多事情都要初始化，让事情有一个具体的起点状 态，比如你要吃饭，碗里得先有饭。在用类创建实例的时候，首先执行的是初始化方法。<br>在上面的例子中，初始化方法里的参数除了 self 以外，还有一个 name，在 Person 类被实例化的同 时，要传给它一个值。self.name = name 的意思是建立实例的一个属性，这个属性的名字也是 name，它的值等于参数 name 所传入的值。要注意的是，这里的属性 self.name 和参数 name 是纯属 巧合，你也可以写成 self.aaa = name，只不过这样写会觉得很别扭。<br>接下来的 def get_name(self) 和 def get_sex(self,sex) 是类里面的另外两个方法，这两个方法除了第一 个参数必须是 self 以外，其它跟函数没有什么区别。你只需要注意的是，两个方法中都用到了 self.name，属性的这种调用方式只能在类里面使用。</p><h3 id="“类”-的实例"><a href="#“类”-的实例" class="headerlink" title="“类” 的实例"></a>“类” 的实例</h3><p>类是对象的定义，实例才是真实的东西。比如 “人” 是一个类，但是 “人” 终究不是具体的某个会喘气 的，只有 “rocky” 才是具体的东西，但他是具有 “人” 这个类所定义的属性和方法。“rocky” 就是 “人” 这 个类的实例。<br>我们继续用上面那个类的例子，直接写一下调用这个类的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    boy = Person(<span class="string">'rocky'</span>)</span><br><span class="line">    print(boy.name)</span><br><span class="line">    name = boy.get_name()</span><br><span class="line">    print(name) </span><br><span class="line">    his_sex = boy.get_sex(<span class="string">'男'</span>)</span><br><span class="line">    print(his_sex)</span><br></pre></td></tr></table></figure><p>上面代码中 boy = Person(‘rocky’) 是利用上面的类创建的实例。创建实例的过程就是调用类 Person()， 首先执行的是初始化函数，上述例子中的初始化函数有两个参数，即 self 和 name，其中 self 是默认参 数，不需要传值，name 则需要给它传值，所以用Person(‘rocky’) 的样式。<br>boy 就是一个实例，它有属性和方法，self.name 是它的属性，<strong>boy.get_name() 和 boy.get_sex(‘男’)</strong> <strong>是通过实例来调用方法</strong>。<br>刚才是以 boy = Person(‘rocky’) 的方式创建了一个实例，仿照这个样式还可以建立更多的实例，比如 girl = Person(‘gakki’) 等，也就是说，一个类可以创建多个实例。</p><p>这就是通过类创建实例，并且通过实例来调用属性和方法的过程</p><p>内容引自Rocky0429博客</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python闭包</title>
      <link href="/ArthurDream/2020/07/16/Python%E9%97%AD%E5%8C%85/"/>
      <url>/ArthurDream/2020/07/16/Python%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><p>我们都知道在数学中有闭包的概念，但此处我要说的闭包是计算机编程语言中的概念，它被广泛的使用 于函数式编程。</p><p>关于闭包的概念，官方的定义颇为严格，也很难理解，在《Python语言及其应用》一书中关于闭包的解 释我觉得比较好 – <strong>闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变 量的值</strong>。乍一看，好像还是比较很难懂，下面用一个简单的例子来解释一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span> </span><br><span class="line">...print(a)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun() </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">...b = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b) </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>毋庸置疑，第一段程序是可以运行成功的，a = 1 定义的变量在函数里可以被调用，但是反过来，第二 段程序则出现了报错。<br>在函数 fun() 里可以直接使用外面的 a = 1，但是在函数 fun1() 外面不能使用它里面所定义的 b = 1，如 果我们根据作用域的关系来解释，是没有什么异议的，但是如果在某种特殊情况下，我们必须要在函数 外面使用函数里面的变量，该怎么办呢？<br>先来看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span> </span><br><span class="line">...a = <span class="number">1</span></span><br><span class="line">...<span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span> </span><br><span class="line">... <span class="keyword">return</span> a </span><br><span class="line">...<span class="keyword">return</span> fun1</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fun() </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f()) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>在函数 fun() 里面，有 a = 1 和 函数 fun1() ,它们两个都在函数 fun() 的环境里面，但是它们两个是互不干扰的，所以 a 相对于 fun1() 来说是自由变量，并且在函数 fun1() 中应用了这个自由变量 – 这个 <strong>fun1()</strong> 就是我们所定义的<strong>闭包</strong>。<br>闭包实际上就是一个函数，但是这个函数要具有 1.定义在另外一个函数里面(嵌套函数)；2.引用其所在 环境的自由变量。<br>上述例子通过闭包在 fun() 执行完毕时，a = 1依然可以在 f() 中，即 fun1() 函数中存在，并没有被收 回，所以 print(f()) 才得到了结果。<br>当我们在某些时候需要对事务做更高层次的抽象，用闭包会相当舒服。比如我们要写一个二元一次函 数，如果不使用闭包的话相信你可以轻而易举的写出来，下面让我们来用闭包的方式完成这个一元二次 方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a,b,c)</span>:</span> </span><br><span class="line">...<span class="function"><span class="keyword">def</span> <span class="title">para</span><span class="params">(x)</span>:</span></span><br><span class="line">...<span class="keyword">return</span> a*x**<span class="number">2</span> + b*x + c </span><br><span class="line">...<span class="keyword">return</span> para</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(f(<span class="number">2</span>)) </span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>上面的函数中，f = fun(1,2,3) 定义了一个一元二次函数的函数对象，x^2 + 2x + 3，如果要计算 x = 2 ， 该一元二次函数的值，只需要计算 f(2) 即可，这种写法更简洁一些。</p><p>内容参考Rocky0429微信公众号</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环 迭代 递归 遍历</title>
      <link href="/ArthurDream/2020/07/15/%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E9%81%8D%E5%8E%86/"/>
      <url>/ArthurDream/2020/07/15/%E5%BE%AA%E7%8E%AF%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-循环（loop）"><a href="#1-循环（loop）" class="headerlink" title="1.循环（loop）"></a>1.循环（loop）</h3><p>循环是指在满足条件的情况下，重复执行同一段代码，比如 while 语句</p><h3 id="2-迭代（Iterate）"><a href="#2-迭代（Iterate）" class="headerlink" title="2.迭代（Iterate）"></a>2.迭代（Iterate）</h3><p>迭代是指按照某种顺序逐个访问对象中的每一项，比如 for 语句</p><h3 id="3-递归（recursion）"><a href="#3-递归（recursion）" class="headerlink" title="3.递归（recursion）"></a>3.递归（recursion）</h3><p>递归是指一个函数不断调用自身的行为，比如斐波那契数列</p><h3 id="4-遍历（traversal）"><a href="#4-遍历（traversal）" class="headerlink" title="4.遍历（traversal）"></a>4.遍历（traversal）</h3><p>遍历是指按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次</p><h3 id="Python中的逐个访问"><a href="#Python中的逐个访问" class="headerlink" title="Python中的逐个访问"></a>Python中的逐个访问</h3><p>在 Python 中，如果想要访问对象中的每个元素，可以像下面这样做，以列表举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'c'</span>,<span class="string">'k'</span>,<span class="string">'y'</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">...print(i,end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">r o c k y </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>除了上述方法以外，还可以像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter = iter(my_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line"><span class="string">'r'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__() </span><br><span class="line"><span class="string">'k'</span></span><br><span class="line">&gt;&gt;&gt;my_iter.__next__() </span><br><span class="line"><span class="string">'y'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上面的 iter() 是一个内建函数，返回的是一个迭代器对象</p><p>在 Python3 中，所有的迭代器对象都有 next() 方法，迭代器，当然是可迭代的，在上面的例子中， next() 就是要获得下一个对象，但是作为一个 “懒惰” 的程序员来说，上面的那种方法一个个的敲太麻 烦了，所以就有了下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">...print(my_iter.__next__())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>上面出现了错误，我们先不管，再来它一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_iter = iter(my_list) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">...print(my_iter.__next__())</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">r </span><br><span class="line">o </span><br><span class="line">c </span><br><span class="line">k </span><br><span class="line">y </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>看了上面演示的例子可以发现，如果我们用 for 循环来写的话，当到了末尾的时候就自动结束了，但是 用了 next() 的话，当完成最后一个的时候它不会自动结束，还会向下继续，但是后面已经没有元素 了，所以就发出了一个 StopIteration 的信息，即停止迭代。<br>在这我们还要再关注一下迭代器对象的另一个特点，看上上个的那个例子就可以知道，对象 my_iter 被 迭代结束后，即每个元素都读取了一遍之后，指针就移到了最后一个元素后面，如果想要再访问的话， 指针并没有自动移动到初始位置，所以会报 StopIteration，如果想要重新开始的话，就需要重新载入 迭代对象。</p><h3 id="文件迭代器"><a href="#文件迭代器" class="headerlink" title="文件迭代器"></a>文件迭代器</h3><p>现在有一个 “test.txt” 的文件，文件内容是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> Rocky </span><br><span class="line">I love Python </span><br><span class="line">a，hhhhhhh</span><br></pre></td></tr></table></figure><p>现在用迭代器来尝试操作这个文件，我们其实在之前两天讲述有关文件的知识的时候已经讲过了，就是 用 readline() 一行一行的读，当然在实际操作中，我们是绝对不会这样做的，因为我们 “懒” 啊，一定要 让它自动进行，比较常用的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'test.txt'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> f: </span><br><span class="line">...print(line,end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">My name <span class="keyword">is</span> Rocky</span><br><span class="line">I love Python </span><br><span class="line">a，hhhhhhh &gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>上面的过程当然用 next() 也能够读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'My name is Rocky\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'I love Python\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line"><span class="string">'a，hhhhhhh'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line"> File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>用 next() 就可以直接读取每行的内容，这就说明文件是天生可迭代的对象，不需要用 iter() 转换。 再者，我们用 for 来实现迭代，本质上就是自动调用 next() ，只不过这个工作被 for 偷偷的做了，所以 for 是活雷锋无疑了。</p><p>文章参考Rocky0429公众号中的部分内容</p>]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础概念 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命名规范</title>
      <link href="/ArthurDream/2020/07/07/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/ArthurDream/2020/07/07/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、命名规范</p><p>1、 项目名全部小写</p><p>2、 包名全部小写</p><p>3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。</p><p>如：public class MyFirstClass{}</p><p>4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。</p><p>如：int index=0;</p><pre><code>public void toString(){}</code></pre><p>5、 常量名全部大写</p><p>如：public static final String GAME_COLOR=”RED”;</p><p>6、所有命名规则必须遵循以下规则：</p><p>1)、名称只能由字母、数字、下划线、$符号组成</p><p>2)、不能以数字开头</p><p>3)、名称不能使用JAVA中的关键字。</p><p>4)、坚决不允许出现中文及拼音命名。</p><p>二、注释规范</p><p>1、   类注释</p><p>在每个类前面必须加上类注释，注释模板如下：</p><p>/**</p><ul><li><p>Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.</p></li><li><p>FileName: Test.java</p></li><li><p>类的详细说明</p></li><li></li><li><p>@author 类创建者姓名</p><ul><li>@Date    创建日期</li></ul></li><li><p>@version 1.00</p></li></ul><p>*/</p><p>2、   属性注释</p><p>在每个属性前面必须加上属性注释，注释模板如下：</p><p>/** 提示信息 */</p><p>private String strMsg = null;</p><p>3、   方法注释</p><p>在每个方法前面必须加上方法注释，注释模板如下：</p><p>/**</p><ul><li><p>类方法的详细使用说明</p></li><li></li><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@return 返回结果的说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>4、   构造方法注释</p><p>在每个构造方法前面必须加上注释，注释模板如下：</p><p>/**</p><ul><li><p>构造方法的详细使用说明</p></li><li></li><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>5、   方法内部注释</p><p>在方法内部使用单行或者多行注释，该注释根据实际情况添加。</p><p>如：//背景颜色</p><pre><code>Color bgColor = Color.RED</code></pre><p>内容仅供个人学习、记录使用，侵删</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session的空属性判断问题</title>
      <link href="/ArthurDream/2020/07/07/session%E7%9A%84%E7%A9%BA%E5%B1%9E%E6%80%A7%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/"/>
      <url>/ArthurDream/2020/07/07/session%E7%9A%84%E7%A9%BA%E5%B1%9E%E6%80%A7%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    记录一个今天遇到的小问题：（新手编程，若有错误，希望各位及时指正，感激不尽）<br>​    首先，若后端放session时，某些属性为空值（比如下面的resume属性），则到了session里时会变为空字符串，而不是null。</p><p>原因：<br>​    首先什么是session？<br>​    “当访问服务器某个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session”</p><p>​    由此可以看出，当访问页面的时候是已开辟了一段内存的，而null是不指向任何对象，不分配内存空间的;空字符串“”才会分配内存空间。</p><p>​    故此时一切对session里空属性的判断不能对null判断，而应是对空字符串判断，如下面的应为sj.resume!=’ ‘而不能是sj.resume！=null</p><p>​    下面是一段前端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">function sendResume(jid,jobName,uname)&#123;</span><br><span class="line"></span><br><span class="line">        alert(&quot;点击确定开始投递&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;*定义个数组放发送的变量并赋值*&#x2F;</span><br><span class="line">        var sj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        sj.jid&#x3D;jid;</span><br><span class="line">        sj.jobName&#x3D;jobName;</span><br><span class="line">        sj.uname&#x3D;uname;</span><br><span class="line">        sj.sid&#x3D;&#39;$&#123;session.sid &#125;&#39;;</span><br><span class="line">        sj.name&#x3D;&#39;$&#123;session.name &#125;&#39;;</span><br><span class="line">        sj.resume&#x3D;&#39;$&#123;session.resume&#125;&#39;;</span><br><span class="line">        &#x2F;*若后端放session时，某些属性为空值，则到了session里时会变为空字符串，</span><br><span class="line">            故此时一切对其空属性的判断不能对null判断，而是对空字符串判断，如下面的sj.resume!&#x3D;&#39;&#39; *&#x2F;</span><br><span class="line">        if (sj.resume!&#x3D;&#39;&#39;) &#123;</span><br><span class="line"></span><br><span class="line">            alert(&quot;要进入ajax了&quot;);</span><br><span class="line">          $.ajax(&#123;</span><br><span class="line">            &#x2F;*请求类型*&#x2F;</span><br><span class="line">            type:&quot;post&quot;,</span><br><span class="line">            &#x2F;*请求路径*&#x2F;</span><br><span class="line">            url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;application&#x2F;sendResume&quot;,</span><br><span class="line">            &#x2F;*设置类型*&#x2F;</span><br><span class="line">            contentType:&quot;application&#x2F;json;charset&#x3D;UTF-8&quot;,</span><br><span class="line">            &#x2F;*向后端传数据，stringify方法将sj转换为json格式*&#x2F;</span><br><span class="line">            data: JSON.stringify(sj),</span><br><span class="line">            &#x2F;*然后在这个弹窗里去显示出来*&#x2F;</span><br><span class="line">            success:function(data) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;*后端return的值默认都装在叫data的变量里*&#x2F;</span><br><span class="line">                if(data&#x3D;&quot;0&quot;)&#123;</span><br><span class="line">                    alert(&quot;投递成功！&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    alert(&quot;投递失败！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                window.location.reload();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            alert(&quot;请先上传简历！&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/ArthurDream/2020/07/06/hello-world/"/>
      <url>/ArthurDream/2020/07/06/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\ArthurDream\assets\css\APlayer.min.css"><script src="\ArthurDream\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello World！</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Demo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
